---
title: 图
date: 2023-07-29 11:14 
categories:
- 计算机基础
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>



## 定义

图G由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中的顶点集合，E(G)表示图G中边的关系的集合。用|V|表示图G中的顶点个数，|E|表示图G中边的条数。

> 线性表可以是空表，树可以是空树，但是图不可以是空图。

## 名词解释

- 有向图

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725121501285.png" alt="image-20230725121501285" style="zoom:50%;" />

  - 弧：有向图中的有向边，是顶点的有序对，记为<v,w>，v,w是顶点，v称为弧尾，W称为弧头
  - 

- 无向图

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725121522921.png" alt="image-20230725121522921" style="zoom:50%;" />

- 简单图和多重图

  1.不存在重复边；2.不存在顶点到自身的边，称为简单图，否则称为复杂图。

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725121412534.png" alt="image-20230725121412534" style="zoom: 50%;" />

  数据结构中只研究简单图。

- 完全图

  对于无向图，结点之间两两相连的图称为完全图，边的个数为n(n-1)/2.

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725121719539.png" alt="image-20230725121719539" style="zoom:50%;" />

  对于有向图，任意两个结点之间存在方向相反的两条弧，边的个数为n(n-1).

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725121832135.png" alt="image-20230725121832135" style="zoom:50%;" />

- 子图

  若对于图G=(V,E)，有图G'=(V',E')，其中V'和E'分别是V和E的子集，那么称G'是G的子图

  > 并非V和E的任何子集都可以构成子图，因为这样的子集可能不是图。

  - 生成子图

    当子图的V'=V时，该子图称为生成子图。

- 结点间连通和强连通：结点v和结点w存在路径(v->w和w->v均可以)，对于无向图来说称为该结点间连通，对于有向图来说称为结点间强连通。

- 连通图和强连通图：对于一个图，任意两结点间均存在路径，这样的无向图称为连通图，有向图称为强连通图。

- 连通分量和强连通分量

  对于一个非连通图，删去一些尽可能少的边形成的极大连通子图称为连通分量，有向图中的极大连通子图称为强连通分量

  - 极大连通子图：尽可能包含更多边的连通子图

  > 强连通分量一定是有环的图。

- 生成树和生成森林

  对于一个连通图，生成树是删去尽可能多的边形成的极小连通子图。

- 度，入度和出度

  顶点的度是指依附于该结点的边的条数，记为TD(v)，入度记为ID(v)，出度记为OD(v)。TD(v)=ID(v)+OD(v).

- 权：每条边可以标上某种带含义的数值，称为边的权值
- 网：带权值的图称为网
- 简单路径：对于路径序列，不出现重复的顶点，称为简单路径
- 简单回路：对于回路序列，除了第一个和最后一个点外，不出现重复的顶点，称为简单回路
- 距离：顶点u到顶点v的最短路径

## 性质

- 如果一个图有n个结点，如果边数小于n-1，那么这个图必是非连通图。

- 如果一个图有n个结点，如果边数大于n-1，那么这个图一定有环。

- 若图中的顶点数是n，则它的生成树有n-1条边。

- 对于具有n个结点，e条边的**无向图**来说，所有结点的度数之和等于边数的2倍。
  $$
  \sum_{i=1}^nTD(v_i)=2e
  $$

- 对于具有n个结点，e条边的**有向图**来说，所有结点的入度总数等于出度总数等于边的条数
  $$
  \sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e
  $$

## 存储

### 邻接矩阵

用一个一维数组存储顶点信息(当顶点信息比较简单时可省去)，用一个二维数组(nxn)存储边之间的关系。

![image-20230725181754596](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725181754596.png)

```cpp
typedef struct{
    char Vex[n]; //顶点表
    int Edge[n][n]; //邻接矩阵，边表
    int vexnum, arcnum; //当前顶点数和弧数(按需取舍)
}MGraph;
```

> 无向图的邻接矩阵是一个对称矩阵，可以采用压缩存储(只存储上三角或者下三角)。

- 特点
  - 对于无向图，第i行或第i列非零元素(或非无穷元素)的个数恰好是顶点i的度TD(vi).
  - 对于有向图，第i行可以找到顶点的出度，第i列可以找到顶点的入度.
  - 容易确定结点是否相连，不容易确定边的总数(需要遍历每个元素)
  - 适合稠密图，不适合稀疏图
  - 设图G的邻接矩阵是A，A^n由n个A相乘得到，A^n[i\][j]表示由结点i到结点j的长度为n的路径条数。
  - 图的邻接矩阵是唯一的。

### 邻接表

用一维结构体数组存储顶点表结点，用链表结点存储边表信息。顶点表中结点i所连的单链表表示依附于结点i的相邻结点，对于有向图来说特指从顶点i出发的弧所连的结点。

![image-20230725184618362](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725184618362.png)

```cpp
//边表结点
typedef struct{
    char adjvex; //弧指向的是哪个结点
    ArcNode *next; //指向下一条弧的指针域
}ArcNode;
//顶点表结点
typedef struct{
    int data; //顶点信息
    ArcNode *first; //第一条弧
}VecNode, AdjList;
//邻接表
typedef struct{
    AdjList[MaxVertexNum] vertices; //邻接表
    int vexnum, arcnum; //图的顶点数和弧数
}ALGraph;
```

- 特点
  - 对于稀疏图可以用邻接表存储
  - 对于要确定两个结点是否存在边，在邻接矩阵中可以在O(1)的时间内查找到，但是在邻接表中需要在相应结点的边表中遍历查找
  - 图的邻接表不唯一，因为边表中结点的次序可调换

### 十字链表(24考纲没有)

针对有向图的一种链式存储，主要解决邻接表找顶点作为入度的入边不方便的问题。在十字链表中，容易找到结点Vi为尾的弧，也容易找到结点Vi尾头的弧，因而容易求得顶点的入度和出度。

![image-20230725185929028](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725185929028.png)

> 从firstin域出发可以找到所有指向当前结点得弧。
>
> 从firstout域出发可以找到所有从当前结点发出得弧。

### 邻接多重表(24考纲没有)

邻接多重表是专门针对于无向图的一种链式存储结构。主要解决是无向图的邻接表存储结构中，有边结点数据冗余的问题(每个边界点有两份存储)。因此邻接多重表中，每个边界点同时链接在两个链表中。

![image-20230725190752524](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230725190752524.png)

## 基本操作

主要了解针对邻接矩阵和邻接表结构的有关图的操作的实现方式，并且关注时间复杂度：

- FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点，则返回-1。

- NextNeighbor(G,x,y)：y是图G中顶点x的一个邻接点，返回顶点x的下一个邻接点，若y是最后一个邻接点，则返回-1。

  - 邻接矩阵存储

    ```cpp
    int NextNeighbor(Graph G,int x,int y){
        if(x!=-1 && y!=-1){
            for(int col=y+1; col<G.vexnum; col++){
                if(G.Edge[x][col]>0 && G.Edge[x][col]<MAXNUM) //MAXNUM表示无穷
                    return col;
            }
        }
        return -1;
    }
    ```

  - 邻接表存储

    ```cpp
    int NextNeighbor(Graph G,int x,int y){
        if(x!=-1 && y!=-1){
            ArcNode *p=G.vertices[x].first; //对应结点链表的第一个结点
            while(p!=NULL && p->data!=y) //寻找邻接顶点y
                p=p->next;
            if(p!=NULL && p->next!=NULL)
                return p->next->data; //返回下一个邻接顶点的数据
        }
        return -1;
    }
    ```
  
    


## 图的遍历

图的遍历和树的遍历的区别是，由于树不存在回路，不会出现同一顶点被访问多次，所以对于图的遍历要设置一个辅助数组visit[]来标记顶点是否被访问过。

### 广度优先遍历

```cpp
bool visit[VEX_NUM]; //访问数组
void BFSTraverse(Graph G){
    for(int i=0;i<G.vexnum;i++){
        visit[i]=false; //初始化访问数组
    }
    for(int i=0;i<G.vexnum;i++){
        if(!visit[i])
            BFS(G,i); //如果vi未被访问过，则从vi开始BFS
    }
}
void BFS(Graph G, int i){
    queue<char> Q; //定义一个辅助队列
    visit[i]=true; //初始顶点标记已访问
    Q.push(i); //初始顶点入队
    while(!Q.empty()){
        int v=Q.pop(); //队头元素出队
        for(int w=FirstNeighbor(G,v); w>=0; w=NextNeighbor(G,v,w)){
            if(!visited[w]){
                Q.push(w);
            	visit[w]=true;
            }
        }
    }
}
```

- 复杂度分析

  V，E分别是图中顶点数和边数

  - 时间复杂度

    - 邻接矩阵存储

      每个顶点均需搜索一次(O(V))，查找每个顶点的邻接点需要O(V)，则总的时间复杂度为O(V^2).

    - 邻接表存储

      每个顶点均需搜索一次(O(V))，查找邻接点每条边都访问一次(O(E))，则总的时间复杂度为O(V+E).

  - 空间复杂度

    在不考虑图本身的存储空间的情况下，无论是邻接表还是邻接矩阵，BFS算法都需要一个辅助队列Q，最坏的情况下空间复杂度为O(V)。

- 广度优先生成树

  采用广度优先遍历图，遍历所有结点和经过的边形成的树称为广度优先生成树。

  > 同一个图的邻接矩阵存储是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一，故故其广度优先生成树也不唯一。

  

### 深度优先遍历

```cpp
bool visit[VEX_NUM]; //访问数组
void DFSTraverse(Graph G){
    for(int i=0;i<G.vexnum;i++){
        visit[i]=false; //初始化访问数组
    }
    for(int i=0;i<G.vexnum;i++){
        if(!visit[i])
            DFS(G,i); //如果vi未被访问过，则从vi开始DFS
    }
}
void DFS(Graph G, int i){
    visit[i]=true; //初始顶点标记已访问
    for(int w=FirstNeighbor(G,v); w>=0; w=NextNeighbor(G,v,w)){
        if(!visit[w]){
            DFS(G,w);
        }
    }
}
```

- 复杂度分析

  - 时间复杂度

    - 邻接矩阵存储

      每个顶点均需搜索一次(O(V))，查找每个顶点的邻接点需要O(V)，则总的时间复杂度为O(V^2).

    - 邻接表存储

      每个顶点均需搜索一次(O(V))，查找邻接点每条边都访问一次(O(E))，则总的时间复杂度为O(V+E).

  - 空间复杂度

    在不考虑图本身的存储空间的情况下，无论是邻接表还是邻接矩阵，DFS算法都需要一个递归工作栈，最坏的情况下空间复杂度为O(V)。

- 深度优先生成树

  采用深度优先遍历图，遍历所有结点和经过的边形成的树称为深度优先生成树。

  > 同一个图的邻接矩阵存储是唯一的，故其深度优先生成树也是唯一的，但由于邻接表存储表示不唯一，故故深度优先生成树也不唯一。

## 图的应用

这部分内容以算法设计题的形式考察的可能性很小，更多的是结合图的实例来考察手动模拟的过程。

### 最小生成树

边的权值之和最小的生成树。

#### 性质

- 针对带权无向/有向连通图，非连通图只能构造最小生成森林
- 最小生成树一般不是唯一的，**只有图G中各边的权值互不相等时**，才会出现唯一的最小生成树，所有的最小生成树有相同的代价
- 最小生成树的边数为顶点数减1

#### Prime（普里姆）算法

- 步骤

  1. 首先，选择图中的任意一个节点作为开始节点。

  2. 初始化一个集合，将开始节点放入集合中。这个集合是用来存放已经被访问过的节点的。

  3. 寻找所有连接集合内节点和集合外节点的边，从中选出权值最小的那条边，并将该边连接的集合外的节点加入到集合中。

  4. 重复步骤3，直到所有的节点都被加入到集合中为止。

  5. 所有被选中的边就构成了最小生成树。

     ![image-20230728213844824](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230728213844824.png)

- 特点

  - 算法时间复杂度是O(V^2)，V是顶点个数，因此适合于求解边稠密的图的最小生成树

#### Kruskal（克鲁斯卡尔）算法

- 步骤
  1. 从权值最小的边开始，按顺序考虑每一条边，如果这条边连接的两个节点不在同一棵树（或集合）中，就将这条边加入到集合中，否则就忽略这条边。
  2. 重复步骤1，直到集合中包含了图中的所有节点，或者所有的边都被考虑过为止。
- 特点
  - 通常采用堆来存放边的集合，并且利用并查集的数据结构，总的时间复杂度为O(Elog2E)，E是图G的边数，因此Kruskal算法适合于边稀疏而顶点较多的图

### 最短路径

当图是带权图时，对于图中任意的两个顶点，它们之间的带权路径长度最短的那条路径称为最短路径。

#### Dijikstra（迪杰斯特拉）算法

- 步骤

  设置了两个辅助数组：dist[]表示源点到其他各顶点的最短路径长度，visit[]表示当前结点是否被访问，path[]表示结点i所对应最短路径的前驱结点(只有一个)。

  1. 初始化dist[]数组：若从v0到vi有弧，则dist[i]为弧上的权值且path[i]=0，否则置dist[i]=∞且path[i]=-1,源点0标记为已访问。

  2. 从未访问的节点集中选取当前距离最短的节点i，visit[i]标记为"已访问"。

  3. 对于剩余未访问的结点中的任意一个顶点vk，若dist[i]+i->k的距离 < dist[k]，更新dist[k]的值，path[k]=i

  4. 重复2-3操作共n-1次，直到所有结点都包含在内.

     ![image-20231105183406574](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231105183406574.png)
     
     求解过程：
     
     ![image-20231105183343554](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231105183343554.png)

- 特点

  - 适用于带权无向/有向图

  - 当图中有负权边时，Dijkstra算法并不适用，因为它不会因为负边的出现而更新已经访问过的顶点的路径长度。

    ![image-20230729105854663](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230729105854663.png)

  - 基于贪心策略

  - 时间复杂度为O(V^2)

#### Floyd（弗洛伊德）算法

- 步骤

  1. 初始化：创建一个二维数组dist，将其所有元素初始化为**无穷大**，除了对角线元素（即，从节点i到节点i的距离）初始化为**0**。然后，将每条边的权重赋给对应的dist数组的元素。

  2. 对于每个节点k，进行以下操作：

     - 对于每个节点i：

       - 对于每个节点j：

         如果通过节点k的路径（即，路径i-k-j）的长度小于当前路径i-j的长度，那么就更新路径i-j的长度为路径i-k-j的长度。

     <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230729111328962.png" alt="image-20230729111328962" style="zoom: 67%;" />

- 特点
  - 适用于带权无向/有向图
  - Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。
  - 时间复杂度为O(V^3)

### 有向无环图描述表达式

有向无环图是可以用来化简含有公共子式的表达式的有效工具：

例如表达式((a+b)\*(b\*(c+d))+(c+d)\*e)\*((c+d)*e)

![image-20230729112204390](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230729112204390.png)

### AOV网和AOE网

有向无环图：若一个有向图不存在环,则称为为有向无环图，简称DAG(Directed Acyclic Graph)图。

- AOV网(Activity on **Vertex** Network)

  顾名思义，用顶点表示活动的有向图。

- AOE网(Activity on **Edge** Network)

  顾名思义，用边表示活动的有向图。

### 拓扑排序

拓扑排序就是为有向无环图(特指AOV网)中的节点确定一种线性顺序，使得每个节点都出现在其所有前驱节点的后面。（王道视频中番茄炒鸡蛋的例子）。

- 拓扑排序步骤

  1. 从AOV网中选择一个没有前驱的顶点并输出。
  2. 从网中删除该顶点和所有以它为起点的有向边。
  3. 重复步骤1和2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止，后一种情况说明有向图中必然存在环

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230729114027466.png" alt="image-20230729114027466" style="zoom:67%;" />

- 逆拓扑排序步骤
  1. 从AOV网中选择一个没有后继的顶点并输出。
  2. 从网中删除该顶点和所有以它为终点的有向边。
  3. 重复1和2直到当前的AOV网为空。
- 特点
  - 用邻接表存储时拓扑排序的时间复杂度为O(V+E)，采用邻接矩阵存储时拓扑排序的时间复杂度为O(V^2)
  - 深度优先遍历也可以实现拓扑排序和逆拓扑排序，在访问时输出相应结点是拓扑排序序列，在递归退出时输出相应结点是逆拓扑排序序列。
  - 除非每个顶点有唯一的前驱和后继关系，否则拓扑排序的结果通常不唯一。
  - 若给定图的邻接矩阵是三角矩阵，则一定存在拓扑序列，反之则不一定成立

### 关键路径

- AOE网的特点

  - 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始
  - 只有在进入某顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生
  - AOE网只有一个入度为0的顶点，称为源点。只有一个出度为0的顶点，称为汇点。
  - 网中的顶点被称为事件，边被称为活动。

- 定义

  对于AOE网来说，从源点到汇点的所有路径中，具有**最大路径长度**的路径称为关键路径，关键路径上的活动称为关键活动。

  > 关键路径决定了完成整个工程的事件

- 名词解释：

  - 事件vi的最早发生时间ve(i)

    指的是从源点到vi的最长路径长度。决定了所有从vi开始的活动能够开工的最早时间。

    设vj是vi的后继结点中的一个，ve(j)=max{ve(i)+Weight{vi,vj}}

    > 可以在拓扑排序的过程中计算。

  - 事件vi的最迟发生时间vl(i)

    vl(汇点)=ve(汇点)。指在不推迟工程完成的前提下，该事件最迟必须发生的时间
    设vj是vi的后继结点中的一个，vl(i)=min{vl(j)-Weight{vi,vj}}

    > 计算vl()值时需要从后往前计算，故可以在逆拓扑排序的基础上计算

  - 活动ai的最早开始时间e(i)
    等于活动ai的起点事件的最早发生事件ve值

  - 活动ai的最迟开始时间l(i)
    等于活动ai的终点事件的最迟发生时间vl值减去活动ai的权值

  - 活动ai的时间余量d(i)
    d(i)=l(i)-e(i)，d(i)=0的活动是关键活动。
    > 若一个活动的时间余量为0，则说明该活动必须如期完成，否则会拖延工程进度。

- 特点
    - 可以通过加快关键活动的方法来缩短关键路径，但是缩短到一定程度，关键活动可能会变成非关键活动
    - 关键路径并不唯一，对于有多条关键路径的工程可以采用缩短公共关键活动或者加快所有关键活动的方法，来缩短工期。