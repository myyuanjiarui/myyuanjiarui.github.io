# 排序

## 名词解释

- 稳定性：对于排序表中两个关键字相同的元素，如果使用某一排序算法后，这两个元素的前后顺序不发生改变，那么就称这个算法是稳定的，否则就称这个算法是不稳定的

  > 算法是否具有稳定性，并不能衡量一个算法的优劣，只是算法的一个性质

- 内部排序：排序期间元素都在内存中。例如冒泡排序、插入排序、选择排序、快速排序、归并排序等。

  > 大多数的内部排序算法都只适用于顺序存储的线性表

- 外部排序：排序期间元素需要不断的在内外存之间移动。通常是当数据太大，无法在内存中装下导致的

## 插入排序

基本思想是将每一次待排序的记录按其关键字大小插入前面已经排好序的子序列中。

> 插入排序可能出现在最后一趟开始前，所有元素都不在最终位置上。比如最小的元素在最后面。

### 直接插入排序

<video src="E:\record\bandicam 2023-08-04 11-05-24-551.mp4"></video>

```cpp
// 迭代版写法一
void insertionSort(std::vector<int>& arr) {
    int i, j, key;
    for (i = 1; i < arr.size(); i++) {
        key = arr[i]; // 待插入的元素
        j = i - 1; // j指向元素i之前的一个元素

        // 将大于key的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }

        // 插入元素
        arr[j + 1] = key;
    }
}
// 迭代版写法二
void iterationInsertSort(int a[], int n){
    for (int i = 0; i < n;i++){
        for (int j = i; j > 0;j--){
            if(a[j]<a[j-1])
                swap(a[j], a[j - 1]);
            else
                break;
        }
    }
}
// 递归版
void recursionInsertSort(int a[], int n){
    if(n==1){
        return;
    }
    recursionInsertSort(a, n - 1);
    for (int i = n - 1; i > 0;i--){ // 每次只将最后一个元素插入排序
        if(a[i]<a[i-1])
            swap(a[i], a[i-1]);
        else
            break;
    }
}
```

- 空间复杂度。O(1)，执行就地排序
- 时间复杂度。在最好情况下，表中元素已经有序，此时每插入一个元素，都需要比较一次，但是不用移动元素，因而时间复杂度为O(n)。最坏情况下，表中元素刚好是排序结果的逆序，总的比较次数和移动次数都达到最大，均为n-1+n-2+n-3+...+1=O(n^2)。综合来看，直接插入排序算法的时间复杂度为O(n^2)。
- 稳定性。每次插入从后往前比较，并且只有后面比前面小才会移动元素，相等不会移动。即直接插入排序是一个**稳定的**排序算法。
- 适用性。既适用顺序存储也适用于链式存储。为链式存储时，可以从前往后遍历结点，对于每个结点，有序的插入到新链表中。

### 折半插入排序

注意到直接插入排序分为比较和移动两项工作，并且是边比较边移动。折半插入排序采取将比较和移动分离的策略，先通过折半查找将待插入位置找到，再进行移动。

```cpp
void InsertSort(int A[], int n){ //折半插入排序
    for(int i=1; i<n; i++){ //循环1~n-1个位置的元素
        if(A[i]<A[i-1]){ //后一个比前一个元素小，需要移动
            //折半查找到待插入位置
            int low=0, high=i-1;
            while(low<=high){
                int mid=(low+high)/2;
                if(mid>A[i]){ //查找左半子表
                    high=mid-1;
                }
                else{ //查找右半子表，注意这里相等也是查找右半子表，保证了算法的稳定性
                    low=mid+1;
                }
            }
            int key = a[i];
            for(int j=i-1; j>high; j--){ 
                 A[j+1]=A[j]; //元素后移
            }
            A[j+1] = key; //赋值
        }
    }
}
```

- 空间复杂度。O(1)
- 时间复杂度。折半插入排序仅减少了元素的比较次数，元素的移动次数没有改变，因此折半插入排序的时间复杂度仍然为O(n^2)。
- 稳定性。如代码注释所说折半查找可以保证**稳定**性。
- 适用性。折半插入排序只适用于顺序存储结构。因为折半查找无法在链式存储中完成。

### 希尔排序

直接插入排序算法的时间复杂度为O(n^2)，但若待排序列为正序时，其时间效率可提高至O(n)，可见当序列基本有序时，时间复杂度可以大幅提升。

基本思想是将待排序的数组分割成若干个子序列，这些子序列是通过选择某个间隔d（称为增量）的元素组成的。首先对这些子序列进行插入排序，然后逐渐缩小增量d，重复上述过程。最后，当增量缩小到1时，整个数组作为一个子序列，再进行一次插入排序。以增量为3的序列举例，如果原始数组是：[8, 5, 9, 7, 4, 2, 6, 3]。那么将分成以下子序列：子序列1: [8, 7, 6]。子序列2: [5, 4, 3]。子序列3: [9, 2].

![img](https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190420100142756-421005088.gif)

> 上图演示的是gap=5,2,1的情况。

```cpp
// 函数定义：希尔排序
void shellSort(std::vector<int>& arr) {
    int n = arr.size();
    // 初始增量为数组长度的一半
    for (int gap = n / 2; gap > 0; gap /= 2) { // 初始化增量为n/2，然后依次减半直到为1，无统一规定
        // 对每个子序列进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            for (int j = i; j >= gap && arr[j - gap] > temp; j -= gap) { // 后移元素
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}
```

- 空间复杂度。O(1)
- 时间复杂度。当n在某个特定范围时，希尔排序的时间复杂度为O(n^(1.3))
- 稳定性。希尔排序**不稳定**。
- 适用性，希尔排序只适用于顺序存储的线性表。

## 交换排序

基本思想是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

> 交换排序每一趟处理都可以确定至少一个元素的最终位置

### 冒泡排序

从后往前或者从前往后两两比较相邻的元素，如果元素逆序那么就交换它们，直到序列比较完。这称它为第一趟排序，结果是最小或最大的元素移动到表的开端或者末尾。以此类推，n-1趟后就可以排好所有元素。

<video src="E:\record\bandicam 2023-08-05 12-09-57-865.mp4"></video>

```cpp
// 函数定义：冒泡排序
void bubbleSort(std::vector<int>& arr) {
    bool swapped;
    for (int i = 0; i < arr.size() - 1; i++) {
        swapped = false;
        // 对未排序部分进行一次冒泡操作
        for (int j = 0; j < arr.size() - i - 1; j++) {
            if (arr[j] > arr[j + 1]) { // 前面的元素大于后面的元素才交换，相等不交换，保证了算法的稳定性
                // 交换元素
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果这一轮没有发生任何交换，说明数组已经排序完成
        if (!swapped)
            break;
    }
}
```

- 空间复杂度。O(1)
- 时间复杂度。最好情况是表中元素已经有序，一趟冒泡后flag=false，退出函数，比较次数n-1次，移动次数为0次，因此时间复杂度为O(n)。最坏情况是表中元素为逆序，需要进行n-1趟排序，第i趟排序要进行n-i次比较，每次比较需要移动3次。因此最坏时间复杂度为O(n^2)。平均时间复杂度也为O(n^2).
- 稳定性。由代码注释知，满足稳定性。
- 适用性。既适用于顺序存储也适用于链式存储。

### 快速排序

基本思想是基于分治。首先选择一个基准元素。然后将其他元素与基准元素比较，分为两个子序列，一个包括所有小于基准的元素，另一个所有包括大于等于基准的元素。递归地对两个子序列进行相同的操作。直至每部分只有一个元素或空为止。

> 408真题中一次划分和一趟划分不一样。一次划分是对左/右区间处理一次，一趟划分是左和右的区间都处理一次。

<video src="E:\record\bandicam 2023-08-05 12-35-12-016.mp4"></video>

```cpp
//背一下模板，代码题排序数组不可以直接sort
int Partition(int A[],int low, int high){
    int start=low;
    int pivot=A[low]; //选择第一个元素作为基准
    while(low<high){
        while(low<high&&A[high]>=pivot) high--;
        while(low<high&&A[low]<pivot) low++;
        swap(A[low], A[high]); //比基准小的元素移动到左端, 比基准大的元素移动到右端
    }
    swap(A[low], A[start]);
    return low;
}
void QuickSort(int A[],int low,int high){
    if(low<high){
        int pivot=Partition(A,low,high); //划分
        QuickSort(A,low,pivot-1); //依次对两个子表进行递归排序
        QuickSort(A,pivot+1,high);
    }
}
```

- 空间复杂度。需要借助一个递归工作栈来保存递归的必要信息。容量与递归最大深度一致，最好情况下为O(log2n)，最坏情况下是表中元素有序或者逆序O(n)。

- 时间复杂度。最坏情况下是表中元素有序或者逆序，O(n^2)。最好情况下每次划分左右子序列长度基本相等，时间复杂度为O(nlog2n)。

  > 快速排序算法是所有内部排序算法中平均性能最优的排序算法。

- 稳定性。快速排序算法**不稳定**。

  > 例如表L={3,<u>2</u>,2}，一趟排序后是{2,<u>2</u>,3}，最终排序序列也是{2,<u>2</u>,3}，显然2和<u>2</u>的相对顺序发生了改变。

- 适用性。快速排序算法只适用于顺序存储。

## 选择排序

基本思想是在未排序序列中找到最小（或最大）的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，经过n-1趟，只剩下一个元素，就不用再选了，至此所有元素均排序完毕。

### 简单选择排序

第i趟选择出剩余未排序元素中的最大或最小元素，放在第i个位置，经过n-1趟后整个排序表有序。

```cpp
void SelectSort(int A[],int n){//递增的简单选择排序
    for(int i=0;i<n-1;i++){
        int min=i; //初始化一个min指针指向当前元素i
        for(int j=i+1;j<n;j++){
            if(a[j]<a[min]){
                min=j; //更新最小元素位置
            }
        }
        if(min!=i){ //交换最小元素
            int tmp=a[min];
            a[min]=a[i];
            a[i]=a[min];
        }
    }
}
```

- 空间复杂度。O(1)

- 时间复杂度。元素间的比较次数与序列初始状态无关，始终是n(n-1)/2，因此时间复杂度为O(n^2)

- 稳定性。简单选择排序是一种**不稳定**的算法

  > 例如：表L={2,<u>2</u>,1}，经过排序后L={1,<u>2</u>,2}，2的相对次序发生变化。

- 适用性。既适用顺序存储也适用链式存储。

### 堆排序

> 堆排序很擅长处理大量数据，比如在一亿个数字中找前100大的数。开始时，取前100个数建一个小顶堆，顶是最小值。对于后面的数，如果比堆顶小就忽略，如果比堆顶大就替换顶值并调整堆。这样操作完成后，堆内就是所求的100个最大数。堆排序的优点是节约空间且处理速度快。
>
> 堆排序过程中比较次数与序列初始状态无关。

- 大根堆(大顶堆)和小根堆(小顶堆)

  堆是一棵完全二叉树。大根堆满足二叉树的所有父节点关键字都大于子节点，小根堆满足二叉树的所有父节点关键字都小于子节点。

- 基本思想

  堆排序就是利用堆这种数据结构，将表中元素建成堆，以大根堆为例，堆顶元素就是最大值，输出堆顶，然后将堆底最后一个元素送入堆顶，调整剩余堆使其仍然满足大根堆，输出剩余堆的堆顶，为次大值，以此类推，经过n-1趟处理输出序列为递减序列。

  <video src="E:\record\bandicam 2023-08-05 21-56-33-540.mp4"></video>

  - 插入和删除

    插入是将元素插到堆的末尾(最后一个元素的后一个位置)，再调整堆。删除是将待删元素与堆的末尾元素交换，再删除末尾元素，再调整堆。

```cpp
//构造初始堆(以大根堆为例)，从⌊n/2⌋个结点(最后一个非叶结点)开始向前依次处理每个分支结点
void BuildMaxHeap(int &A[], int n){
    for(int i=n/2;i>0;i--){
        HeapAdjust(A,i,n); //对以结点i为根的子树进行调整
    }
}
void HeapAdjust(int &A[],int k, int n){
    for(int i=2*k;i<=n;i*=2){
        if(i<n-1&&A[i]<A[i+1]) i++;//如果结点k的左孩子小于右孩子，i指向右孩子
        if(A[k]>A[i]) break; //父节点大于所有子节点，无需调整
        else{
            int tmp=A[k];
            A[k]=A[i];
            A[i]=tmp;
            k=i; //修改k的值继续向下处理下一个子树
        }
    }
}
//堆排序，输出堆顶元素
void HeapSort(int &A[],int n){
    BuildMaxHeap(A,n); //初始化建堆
    for(int i=n-1;i>0;i--){ //n-1趟输出和调整
        print(A[0]); //输出堆顶元素
        //交换堆顶和堆底元素
        int tmp=A[i];
        A[i]=A[0];
        A[0]=tmp;
        HeapAdjust(A,0,i); //调整剩余的i个关键字整理成堆
    }
    // 单独输出最后一个元素
    print(A[0]);
}
```

- 空间复杂度。O(1)

- 时间复杂度。建立堆的时间复杂度为O(n)。堆排序输出的过程中每次调整的时间复杂度为O(log2n)，共有n-1次，故堆排序的时间复杂度是O(nlogn).

- 稳定性。堆排序是一种**不稳定**的算法

  > 对于表L={1,<u>2</u>,2}构造大顶堆，最终排序序列为L={1,2,<u>2</u>}(大顶堆依次输出堆顶后再逆序)

- 适用性。堆排序只适用于顺序存储。

## 归并排序

基本思想是将两个或两个以上的有序表合并为一个新的有序表。每次合并两个有序表称为2路归并排序，合并n个有序表称为n路归并排序。

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230807162252376.png" alt="image-20230807162252376" style="zoom:80%;" />

```cpp
void Merge(int A[],int B[], int low, int mid, int high){ //采用递增排序, B数组是A数组的复制
    int i=low, j=mid+1; //建立两个指针
    int k;
    for(k=low;i<=mid&&j<=high;k++){
        if(B[i]<=B[j]) //等号保证了算法的稳定性
            A[k]=B[i++];
        else
            A[k]=B[j++];
    }
    while(i<=mid)
        A[k++]=B[i++]; //若左表未检测完，复制
    while(j<=high)
        A[k++]=B[j++]; //若右表未检测完，复制
}
void MergeSort(int A[], int B[], int low, int high){
    if(low<high){
        int mid=(low+high)/2;
        MergeSort(A, B, low, mid); //左侧子序列
        MergeSort(A, B, mid, high); //右侧子序列
        Merge(A, B, low, mid, high);
    }
}
int main()
{
  	int A[n] = {...};
  	int B[n]; 
  	copy(A, A + n, B);
  	MergeSort(A, B, 0, n - 1);
}
```

- 空间效率。辅助数组B，共占用O(n)

- 时间效率。每趟归并的时间复杂度为O(n)，共需进行log2n趟归并，故算法的时间复杂度为O(nlog2n)。

  > 一般而言，对N个元素进行k路归并排序时，排序的趟数m=⌈log_k^N⌉。
  >
  > 归并排序过程中比较次数的数量级与序列初始状态无关。

- 稳定性。稳定的算法

- 适用性。归并排序只适用于顺序存储。

## 基数排序

基本思想是基于关键字的各位大小进行排序。直观常用的方法是最低位优先(LSD)法，按关键字权重递增依次排序，最终形成一个有序序列。排序过程中需要借助r个队列进行"分配"和"收集"。r是每一位的基数大小，比如十进制数985，每一位的基数是10(0~9)。

假设对以下十个记录使用LSD方法进行递增排序：

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230807164602184.png" alt="image-20230807164602184" style="zoom:67%;" />

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230807164805792.png" alt="image-20230807164805792" style="zoom:67%;" />

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230807164828885.png" alt="image-20230807164828885" style="zoom:67%;" />

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230807164845941.png" alt="image-20230807164845941" style="zoom:67%;" />

- 空间效率。需要借助r个队列，故空间复杂度为O(r)。
- 时间效率。基数排序需要进行d趟分配和收集，每一趟分配需要O(n)，收集需要O(r)，所以总的时间复杂度为O(d(n+r))，与序列初始状态无关
- 稳定性。基数排序是稳定的。(“基你太稳”)
- 适用性。基数排序只适用于链式存储。

## 桶排序

在553C++程序设计中，实际上认为桶排序就是基数排序。但是实际上桶排序不是按照数位来划分，而是按照数值区间来划分的。

```cpp
int getDigit(int x, int d) {
    while (d--) {
        x /= 10;
    }
    return x % 10;
}

void radixSort(int arr[],int n){
    list<int> l[10]; // 十进制基数lian
    for (int d = 0; d < 3;d++)
    {
        //假设只排序到百位，也就是一共排序3次
        for (int i = 0; i < n;i++){
            //将数组元素链接到链表
            int p = getDigit(arr[i], d);
            l[p].push_back(arr[i]);
        }
        int j = 0;
        int aux[50];
        for (int i = 0; i <= 9;i++){
            while(!l[i].empty()){
                //依次取出链头元素
                int digit = l[i].front();
                aux[j++] = digit;
                l[i].pop_front();
            }
        }
        for (int i = 0; i < n; i++){
            arr[i] = aux[i];
        }
    }
}
```



## 各种排序算法性质总结

![image-20230807170406907](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230807170406907.png)

> 若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。
>
> 若n很大，且关键字的位数较少且可以分解时，采用基数排序较好。
>
> 当关键字本身信息量较大，避免耗费大量移动关键字，可以采用链表作为存储结构

## 外部排序

### 基本概念

当文件中记录过多，无法将整个文件复制进内存中进行排序，那么就需要将待排序序列存储在外存，排序时再把数据一部分一部分调入内存进行排序。

### 基本方法

外部排序通常采用归并排序法。包括两个阶段：1.根据内存缓冲器大小将外存上的文件分成若干个子文件，然后逐个送入内存进行**内部排序**，形成内部有序的初始归并段或顺串。2.对这些归并段进行逐趟归并，直至整个文件有序。

### 优化方法

在外部排序中的时间代价主要考虑访问磁盘的次数，即I/O次数。每一趟归并都涉及到从磁盘读取数据和将数据写回磁盘的操作。，因为磁盘块大小不变，数据量不变，所以每趟归并的I/O总次数不变，因此减少归并的趟数就可以减少时间开销。对r个初始归并段，做k路归并，则归并树可用k叉树表示，若树高为h，则归并趟数=h-1=⌈log_k^r⌉，由此可见减少归并趟数可转化为增加归并路数和减少初始归并段数来实现。

#### 增大归并路数

- 多路平衡归并树

  所谓多路平衡归并树就是：1.最多只能有k个段归并为一个。2.每一趟归并中，若有m个归并段，则经过这一趟处理可以得到⌈m/k⌉个新的归并段。

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230808125708619.png" alt="image-20230808125708619" style="zoom:67%;" />

- 败者树

  一味的增大归并路数k，可能会导致内部归并的开销时间增加，因此为了使内部归并不受k的增大影响，引入败者树。

  ![](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230808130118582.png)

  ![image-20230808130149028](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230808130149028.png)

  归并路数k的增加还会导致输入缓冲区个数增加，在内存空间不变的情况下，势必要减少每个输入缓冲区容量，进而导致I/O次数增大。

#### 减少初始归并段

- 置换-选择算法

  1. **初始化工作区**：从输入文件（FI）读取w个记录到工作区（WA）。
  2. **选择最小记录**：在WA中找到关键字最小的记录，称为MINIMAX记录。
  3. **输出MINIMAX记录**：将MINIMAX记录输出到输出文件（FO）。
  4. **读取新记录**：如果FI不为空，从FI读取下一个记录到WA。
  5. **选择新的MINIMAX记录**：从WA中所有关键字**大于当前MINIMAX记录**的记录中选出最小关键字记录，作为新的MINIMAX记录。
  6. **检查新的归并段**：如果新读入的记录的关键字小于当前归并段的最后一个记录的关键字，则该记录属于下一个归并段。
  7. **重复生成归并段**：重复步骤3到5，直到WA中无法选出新的MINIMAX记录，输出一个归并段的结束标志到FO。
  8. **生成全部初始归并段**：重复步骤2到6，直到WA为空，得到全部初始归并段。

  通过这种方式，置换-选择算法能够有效地生成初始归并段，为后续的多路归并排序做好准备。

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230808131726924.png" alt="image-20230808131726924" style="zoom:67%;" />

- 最佳归并树

  经过置换选择算法后，得到的是不同长度的归并段。引入最佳归并树通过考虑每个归并段的长度来平衡归并过程，避免了某些归并操作处理大量记录而其他归并操作处理较少记录的情况。在外部排序中，I/O操作通常是性能瓶颈，因此引入树的带权路径长度WPL，WPL与每个归并段的读/写次数成正比，因此最小化WPL也意味着最小化总的I/O操作次数。

  构造最佳归并树与哈夫曼算法相同。

  但是由于初始归并段可能不足以构成一棵严格k叉树，因此需要添加长度为0的"虚段"，下面是判断添加"虚段"数目的方法。

  设n0表示度为0的结点数，nk表示度为k的结点数，则nk=(n0-1)/(k-1)（所有结点的度数之和+1=不同度数的结点数之和）

  - 若(n0-1)%(k-1)=0，则说明刚好可以构成严格k叉树，无需添加0虚段
  - 若(n0-1)%(k-1)=u≠0，则说明需要加上k-u-1个0虚段，就可以建立归并树。

  > 简易方法：
  >
  > 因为K路归并的结点度数只能为K或者0，所有由所有结点的度数之和+1=所有结点总数目，可以推出
  > $$
  > 设K路归并树中分支结点数为n，虚段数为x，初始归并段数目为a，则
  > \\kn=n+a+x-1
  > \\得到n=\frac{a+x-1}{k-1}
  > 因为a,k已知，根据n是正整数求出最小的x
  > $$
  > eg.假设初始归并段数目为18，采用5路平衡归并，需补充多少虚段数？
  >
  > 答案：3

