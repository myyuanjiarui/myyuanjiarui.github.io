---
title: 串(KMP算法)
date: 2023-07-29 11:14 
categories:
- 计算机基础
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>



## 串的概念

- ~~前缀~~

  ~~字符串中从第一个字符开始一直到某个位置(除了最后一个字符)的字符组成的子串。~~

- ~~后缀~~

  ~~字符串中从某个位置(除了第一个字符)一直到最后一个字符的字符组成的子串。~~

- ~~部分匹配值(Partial Match, PM)~~

  ~~字符串的前缀和后缀中的最长公共前后缀的长度~~

    > ~~以字符串'ababa'为例：~~
    >
    > ~~'a'的前缀和后缀为空，部分匹配值为0~~
    >
    > ~~'ab'的前缀是'a';后缀是'b'，{a}∩{b}=∅，则其部分匹配值为0~~
    >
    > ~~'aba'的前缀是'a','ab';后缀是'a','ba'，{a,ab}∩{a,ba}={a}，则其部分匹配值为1~~
    >
    > ~~'abab'的前缀是'a','ab','aba';后缀是'b','ab','bab'，{a,ab,aba}∩{b,ab,bab}={ab}，则其部分匹配值是2~~
    >
    > ~~'ababa'的前缀是'a','ab','aba','abab';后缀是'a','ba','aba','baba'，{a,ab,aba,abab}∩{a,ba,aba,baba}={aba}，则其部分匹配值是3~~

- 模式匹配

  子串的定位操作称为串的模式匹配，即求子串在主串中首次出现的位置。

- 模式串

  子串一定存在于主串中，模式串不一定存在于主串中，换言之，模式串是不一定能在主串中找到的

## 核心思想

暴力匹配中，每趟匹配失败都要字串都要从头和主串的下一个位置重新开始比较。但是如果在某一次已匹配相等的前缀序列中有某个后缀刚好是子串的前缀，就可以直接将子串滑动到与这个后缀对齐的位置（跳过了几个字符的比较），主串的指针无需回溯，直接从上一次比较的末尾之后继续比较，因此时间复杂度为O(n+m)(朴素算法的时间复杂度为O(mn))，n为主串长度，m为子串长度。

- next数组

  存放的是j下一次匹配需要指向的子串的位置，第一位和第二位分别填0和1，后续的值移动子串找公共前缀，填j.

  > 为了公式简洁，next数组有时整体+1或者-1

- nextval数组

  next数组还有一些缺陷，设P为模式串，P[next[i]] 等于 P[i] 时，会造成不必要的比对。这是因为当 P[next[i]] = P[i] 时，P[next[i]] 与主串的比对已经在 P[i] 与主串比对时完成，无需再比对一遍。

  优化算法：

  ```cpp
  nextval[1]=0;
  for(int j=2; j<=P.length(); j++){
      if(P[next[j]]==P[j])
          nextval[j]=nextval[next[j]];
      else
          nextval[j]=next[j];
  }
  ```


- 示例动图

  <img src="https://pic4.zhimg.com/v2-bb8efb4778bf4e30b1aae3ed4700523f_b.webp" alt="动图" style="zoom: 67%;" />

