---
title: 查找
date: 2023-07-29 11:14 
description: 考研时王道408的学习笔记
categories:
- 计算机基础
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>



## 名词解释

- 关键字：数据元素中唯一标识该元素的某个数据项的值。在数组中，元素的关键字就是数组的值
- 平均查找长度(ASL)：所有查找情况中进行关键字比较次数的平均值。

## 顺序查找

- 无序线性表ASL

  设顺序查找每个元素的查找概率相同，即为1/n，n为元素个数。若查找成功，元素在第一个位置查找到1/n，元素在第二个位置查找到2/n..，故
  $$
  ASL_{成功}=\frac{1}{n}+\frac{2}{n}+...+\frac{n}{n}=\frac{\frac{n(n+1)}{2}}{n}=\frac{n+1}{2}
  $$
  查找并不成功，显然需要比较n次。即
  $$
  ASL_{失败}=n
  $$

- 有序线性表ASL

  有序线性表查找成功的ASL与无序线性表一样。

  查找失败的情况可以不用走到表尾就能返回失败的信息。如果画成查找判定树可以看到有n+1种查找失败的情况，每种情况等可能，故每种失败情况的概率都是1/(n+1)，

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230731201216552.png" alt="image-20230731201216552" style="zoom: 50%;" />
  $$
  ASL_{失败}=\frac{1}{n+1}+\frac{2}{n+1}+...\frac{n}{n+1}+\frac{n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
  $$

  > 最后两个失败结点都需要比较n次。

## 折半查找

折半查找**仅适用于有序的顺序表**，不适合不支持随机存取的链式结构。若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点(成功结点)和n+1个方形结点(失败结点)。所有的左孩子小于父节点，所有的右孩子大于父节点。

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230731201939223.png" alt="image-20230731201939223" style="zoom:67%;" />

- ASL

  根据查找判定树，第k层的2^(k-1)个结点的关键字比较次数都是k次。
  $$
  ASL_{成功}=\frac{1}{n}(1\times1+2\times2+...+h\times2^{h-1})\overset{\text{错位相乘法}}{=}\frac{n+1}{n}log_2{(n+1)}-1\approx log_2(n+1)-1
  $$

  $$
  ASL_{失败}=\frac{1}{n+1}\sum{每个失败结点的关键字比较次数}
  $$

## 分块查找

又称为索引顺序查找。其基本思想是将查找表分成若干个块，**块内元素可以无序**，但块间元素是有序的，第一个块中的最大元素小于第二个块中的最小元素，以此类推。再建立一个索引表，索引表每个元素记录某块的最大元素和该块第一个元素的位置。索引表是有序的。先用顺序查找或者折半查找在索引表中找到待查元素所在块，再在对应块内进行顺序查找。

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230731204328815.png" alt="image-20230731204328815" style="zoom:67%;" />

- ASL

  设索引查找和块内查找的ASL分别为L1和L2，均采用顺序查找，长度为n的查找表均匀地分成b块，每块有s个记录。
  $$
  ASL_{成功}=L_1+L_2=\frac{b+1}{2}+\frac{s+1}{2}\overset{\text{b*s=n}}{=}\frac{s^2+2s+n}{2s}，
  \\此时，若s=b=\sqrt{n}，ASL_{min}=\sqrt{n}+1
  $$
  

## 树型查找

(考纲没有，但是2014年选择题涉及了AVL树的构造)

### 二叉排序树(BST)

- 定义

  左子树的**所有结点**的关键字均**小于**根节点，右子树的**所有结点**的关键字均**大于**根结点

- 查找

  根据BST的性质递归查找二叉排序树

- 插入

  插入结点只能作为叶结点，所插入位置一定是查找失败时查找路径上访问的最后一个结点的左孩子或右孩子。

- 删除

  分三种情况

  1. 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质
  2. 若结点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，代替z的位置
  3. 若z有左右两棵子树，则令z的直接后继(或直接前驱)替代z，然后从二叉树中删去这个直接后继(或直接前驱)，这样就转化成了第1或2种情况

### 平衡二叉树(AVL树)

- 定义

  树上任意一个结点的左子树和右子树的深度之差不超过1。定义结点左右子树的高度差为该结点的平衡因子，AVL树种结点的平衡因子的值只能是-1，0或1

- 插入

  与BST树插入策略相同，不过若导致了不平衡，需要进行调整。分以下四种情况

  - LL平衡旋转(右单旋转)。新插入结点在结点A的左孩子的左子树上。

    图中结点旁的数值代表平衡因子，用方块表示相应结点的子树，下方数值代表子树的高度。

    ![image-20231127223024469](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231127223024469.png)

  - RR平衡旋转(左单旋转)。新插入结点在结点A的右孩子的右子树上。

    ![image-20231127223202329](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231127223202329.png)

  - LR平衡旋转.新插入结点在结点A的左孩子的右子树上。

    ![image-20231127223245692](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231127223245692.png)

  - RL平衡旋转。新插入结点在结点A的右孩子的左子树上。

    ![image-20231127223317581](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231127223317581.png)

- 删除

  - 用二叉排序树的方法对待删结点w进行删除

  - 若导致了不平衡，从结点w开始向上回溯，找到第一个不平衡的结点z(即最小不平衡子树)，y为结点z的高度最高的孩子结点，x是结点y 高度最高的孩子结点

  - 然后对以z为根的子树进行平衡调整，其中x，y和z可能的位置有4种

    - y是z的左孩子，x是y的左孩子=>LL旋转
    - y是z的左孩子，x是y的右孩子=>LR旋转
    - y是z的右孩子，x是y的左孩子=>RR旋转
    - y是z的右孩子，x是y的左孩子=>RL旋转

    > AVL树的插入操作仅需要对z为根的子树进行平衡调整，而删除操作需要先对以z为根的子树进行平衡调整，如果调整后仍然不平衡，可能需要对z的祖先结点进行平衡调整，甚至回溯到根节点。

## B树和B+树

### B树

![image-20230801203459104](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230801203459104.png)

#### 特点

1. 平衡树，且所有结点的平衡因子为0

2. m阶B树每个结点最多有m棵子树，即每个结点最多有m-1个关键字

3. m阶B树除根结点外的所有非叶结点至少有⌈m/2⌉个子树，即这些结点至少有⌈m/2⌉-1个关键字

   > 根节点的子树数∈[2,m]，关键字数∈[1,m-1]
   >
   > 其他非叶结点的子树数∈[⌈m/2⌉,m]，关键字数∈[⌈m/2⌉-1,m-1]

4. **所有叶结点代表失败结点**，不存储任何信息，叶结点的上一层结点通常称为终端结点

5. 结点内部的关键字是有序的

6. 关键字左侧指针所指子树的所有关键字都小于该关键字，关键字右侧指针所指子树的所有关键字都大于该关键字

7. 具有n个关键字的m阶B树，有n+1个叶结点。因为叶结点是查找失败的区间，可以这么理解，n个关键字将(-∞，+∞)划分为n+1个区间，每个区间对应一个叶子结点。

#### B树的高度
这里计算的B树的高度不包括最后一层不包含任何信息的叶结点所处的那一层。

- 最小高度

  尽可能地让每个结点都含有m-1个关键字，设一棵包含n个关键字，高度为h，阶数为m的B树，则
  $$
  n\leq(m-1)(1+m+m^2+...+m^{h-1})=m^h-1
  \\=>h\geq \log_m(n+1)
  $$
  
- 最大高度

  尽可能让每个结点只有⌈m/2⌉-1个关键字，根结点可以只有1个关键字，则
  $$
  n\geq 1+(2+2⌈m/2⌉+...+2⌈m/2⌉^{h-1})\times(⌈m/2⌉-1)=2⌈m/2⌉^{h-1}-1
  \\=> h\leq \log_{⌈m/2⌉}(\frac{n+1}{2})+1
  $$

#### B树的查找
即根据B树的逻辑去查找。每个结点都是含有关键字的有序表，因此查找结束的位置有可能是非叶结点和非终端结点。
#### B树的插入
B树的插入位置一定是最底层的某个非叶结点即终端结点。
插入关键字不超过原来结点的关键字上限m-1，则直接插入。否则采用如下策略：从中间位置(⌈m/2⌉)将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置(⌈m/2⌉)的结点插入原结点的父结点中，动画如下：

![bandicam 2023-08-02 12-08-52-733](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-08-52-733.gif)

![bandicam 2023-08-02 12-11-53-094](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-11-53-094.gif)

当中间位置结点插入父结点后，导致父结点的关键字个数也超过了上限，则继续这种分裂操作，进而导致B树高度加1，动画如下：

![bandicam 2023-08-02 12-15-51-600.mp4](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-15-51-600.mp4.gif)

#### B树的删除
B树的删除操作可以在任意位置，若删除结点在终端结点，且删除后终端结点不小于⌈m/2⌉-1，则直接删除。
若删除结点不在终端结点，则使用该结点的直接前驱或者直接后继结点来顶替。
使用直接前驱动画：

![bandicam 2023-08-02 12-49-24-137.mp4](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-49-24-137.mp4.gif)

使用直接后继动画：

![bandicam 2023-08-02 12-50-37-763](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-50-37-763.gif)

若删除结点后终端结点的关键字个数低于⌈m/2⌉-1，有两种情况：

- 兄弟够借。所谓兄弟够借就是借用兄弟结点的关键字，并且借用后不影响兄弟结点（关键字个数不小于下界）。
    - 右兄弟够借。用当前结点的后继和后继的后继来填补空缺。动画如下：
    
      ![bandicam 2023-08-02 12-51-54-246](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-51-54-246.gif)
    
    - 左兄弟够借。用当前结点的前驱和前驱的前驱来填补空缺。动画如下：
    
      ![bandicam 2023-08-02 12-53-48-302](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-53-48-302.gif)
    
- 兄弟不够借。即此时当前结点的左右兄弟结点的关键字个数都是⌈m/2⌉-1。则将关键字删除后，将其与左或右兄弟和双亲结点关键字合并。动画如下：
  
  ![bandicam 2023-08-02 12-55-00-065](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-55-00-065.gif)
  
  若此时双亲结点的关键字个数也小于下限了，则进一步处理双亲结点，动画如下：
  
  ![bandicam 2023-08-02 12-57-10-935](https://gitee.com/Marches7/piture-bed/raw/master/img/bandicam%202023-08-02%2012-57-10-935.gif)

### B+树

![image-20230802161555001](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230802161555001.png)

#### 特点

对于一颗m阶的B+树有如下特点

- 每个分支结点最多有m棵子树
- 当根节点非叶时，其至少有两颗子树，其他分支结点至少有⌈m/2⌉棵子树
- 结点的子树个数与关键字个数相等
- 所有叶结点包含全部的关键字和指向相应记录的指针，叶结点中按关键字大小顺序排序，**相邻叶结点通过指针链接在一起**。所以B+树有两种查找运算：一种是从最小叶结点开始的顺序查找(只遍历叶结点)，另一种是从根结点开始的多路查找。
- 所有分支节点仅包含它的各个子节点中关键字的最大值和指向其子节点的指针

#### 与B树的异同

|                | m阶B树                                           | m阶B+树                                                      |
| -------------- | ------------------------------------------------ | ------------------------------------------------------------ |
| 类比           | 二叉查找树的进化-->m叉查找树                     | 分块查找的进化-->多级分块查找                                |
| 关键字与分叉   | n个关键字对应n+1个分叉(子树)                     | n个关键字对应n个分叉(子树)                                   |
| 结点包含的信息 | 所有结点都包含记录的信息                         | 只有最下层叶子结点才包含记录信息(可以使得结点能容纳更多关键字，从而使得树更矮) |
| 查找方式       | 不支持顺序查找，查找的结束位置可以在任何一层结点 | 支持顺序查找。查找成功或失败都会到达最下一层结点             |

相同点：根节点最少有一个关键字，其他结点最少有⌈m/2⌉-1个关键字，任何一个结点的子树都要一样高。

## 散列表

### 名词解释

- 散列函数：把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr
- 冲突：当两个不同的关键字经过散列函数后被映射到同一地址，就称这两个关键字发生了冲突
- 散列表：建立了关键字和存储地址之间的一种直接映射关系，是一种可以根据关键字直接访问的数据结构

### 散列函数

散列函数需要满足尽可能减少冲突，能够在较短时间计算出关键字的散列地址，定义域和值域满足要求等特点，常见的散列函数有：

- 直接定址
  $$
  Hash(key)=akey+b
  $$
  这种计算方式不会产生冲突，但若关键字分布不连续就会产生空间浪费

- 除留余数
  $$
  Hash(key)=key\%p
  $$
  p是小于散列表长的最大质数。这种方法可以将关键字等概率的映射到散列空间任意位置，但有产生冲突的可能性

- 数字分析法

  针对关键字可能在某些数位上的频率不一定相同，应该选取数码分布较均匀的若干位作为散列地址。例如手机号138xxxx，138比较不均匀，xxxx分布较均匀

- 平方取中法

  顾名思义，取关键字的平方值的中间几位作为散列地址，这种方法得到的散列地址与关键字每位都有关系，适用于关键字的每位取值不够均匀或均小于散列地址所需的位数。

### 处理冲突的方法

用Hi表示处理冲突中第i次探测得到的散列地址，m表示散列表长，假设H1发生冲突，则计算H2，依次类推直到Hk不发生冲突为止。

- 开发地址法

  是指存放新表项的地址既向同义词开放，又向非同义词开放。
  $$
  H_i=(H(key)+d_i)\% m
  $$
  di是增量序列。

  - 线性探测法。di依次取0，1，2...m-1。这种方法容易导致大量元素在相邻的散列地址上"聚集"或"堆积"起来，降低了查找效率
  - 平方探测法。di依次取0^2，1^2，-1^2,2^2,-2^2...，又称为二次探测法，这种方法可以避免堆积问题，但是缺点是不能访问散列表中的所有位置
  - 双散列法。使用两个双散列函数。
    $$
    H_i=(Hash_1(key)+i×Hash_2(key))\%m
    $$
    双散列法最多经过m-1次探测就会遍历表中所有位置，回到Hash_1(key)的位置

- 拉链法

  利用顺序存储和链式存储相结合的方法解决非同义词之间发生冲突(不同的关键字可能会通过散列函数映射到同一地址)，可以把所有的同义词存储在一个线性链表中。

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230803121940555.png" alt="image-20230803121940555" style="zoom:67%;" />

### 散列表查找及性能分析

- 查找：

  1. 初始化Addr=Hash(key)
  2. 检查Addr位置是否有记录，无记录，返回查找失败；有记录比较它的key值，相等，则返回查找成功；否则执行步骤3
  3. 根据冲突解决策略计算下一散列地址，返回步骤2

- ASL

  - 查找成功

    给定一组含有n个关键字集合，将关键字集合按照散列函数和冲突策略依次插入到散列表中，设每个关键字ai的查找过程中的比较次数为ki，则
    $$
    ASL_{成功}=\frac{\sum_{i=1}^nk_i}{n}
    $$

  - 查找失败

    查找失败可以这么理解，以除留余数和线性探测举例，当一个关键字经过Hash计算得到Addr，然后会发现不符合当前Addr存储的值，然后会向后探测下一个值，依次类推直到探测的位置的值为空，则表明存储失败，因为线性探测如果存在一定是连续存放，对每个**可能涉及的**Addr都进行这种操作，得到步长总数(比较次数)，再除以可能涉及的Addr的总数，得到ASL_失败。

  - 散列表的查找效率(或ASL)取决于三个因素

    - 散列函数

    - 冲突解决策略

    - 装填因子，记为α，可以理解为表的装满程度
      $$
      \alpha=\frac{表中记录数n}{散列表长度m}
      $$

      > 散列表的查找效率或者ASL不依赖于表中记录数n和散列表长度m.
      >
      > α越大，表越满，冲突可能性越大，查找效率越低。
