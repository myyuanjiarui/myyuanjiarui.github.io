---
title: 内存管理
date: 2023-07-29 11:14 
categories:
- 计算机基础
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>




## 内存管理概念

### 程序的链接

指用户源代码编译形成的若干目标模块和相关库函数链接形成一个完整模块。

程序链接的方式：

- 静态链接

  程序运行之前，将若干目标模块和相关库函数链接形成一个完整模块，不再拆开。

- 装入时动态链接

  在模块装入内存时，采用边装入边链接的方式，便于修改。

- 运行时动态链接

  在程序执行时，才将模块调入内存并且链接相关库函数

### 程序的装入

指程序链接后的完整模块放入内存中运行。

程序模块装入的方式：

- 绝对装入

  程序中的逻辑地址和实际内存地址完全相同，可以直接装入内存，只适用于单道程序环境

- 可重定位装入

  也被称为静态重定位，程序的逻辑地址从0开始，装入内存时给所有地址加一个固定的偏移量(被称为重定位)

- 动态运行时装入

  又称为动态重定位，装入时仍然保持使用逻辑地址，只有到程序真正运行时才借助重定位寄存器变成物理地址，采用动态重定位允许程序在内存中发生移动。

  优点：可以将程序分配到不连续的存储区，程序运行前可以只装入部分代码，运行期间根据需要动态申请分配内存，便于程序段共享

### 内存保护

内存保护机制用于确保每个进程都有独立的，不受影响的内存空间。可采取以下两种方法：

- 上、下限寄存器：在CPU中设置一对上、下限寄存器，表明CPU运行某进程所能读写的内存范围
- 重定位寄存器(又称基地址寄存器)和界地址寄存器(又称限长寄存器)：重定位寄存器存放最小的物理地址，界地址寄存器存放逻辑地址的最大值。将逻辑地址与界地址寄存器比较，若未发生地址越界，则加上重定位寄存器形成物理地址。

## 连续分配管理方式

是指为用户程序分配一个连续的内存空间。具体包括：

- 单一连续分配

  用户区内存中仅有一道用户程序

- 固定分区分配

  将用户区内存划分成若干区域

  - 分区大小相等

  - 分区大小不等

    建立一张分区使用表，管理分区。容易产生许多内部碎片(存在于分区内的内存碎片)，造成空间浪费。

    <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011212739776.png" alt="image-20231011212739776" style="zoom: 67%;float:left" />

- 动态分区分配

  动态为进程分配内存，使分区大小刚好满足进程需要

  ![image-20231011213036288](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011213036288.png)

  容易产生许多外部碎片(存在于分区外的内存碎片)，需要使用紧凑技术来解决(类似Windows的磁盘碎片整理)

  - 空闲块选择策略

    当内存中有多个足够大的空闲块，操作系统必需选择分配哪个内存块给进程使用。

    - 首次适应算法：空闲块按照地址递增次序排列，找到大小能满足要求的第一个空闲分区给作业
    - 邻近适应算法：从上次查找结束的位置继续查找，找到第一个满足要求的空闲区
    - 最佳适应算法：空闲分区按容量递增的次序排列，找到第一个能满足的空闲区(自然也是满足要求的最小空闲分区)
    - 最坏适应算法：空闲分区按容量递减的次序排列，找到第一个能满足的空闲区(自然也是满足要求的最大空闲分区)

## 非连续分配管理方式

### 分页管理方式

把主存划分成大小相等的固定块，进程在执行时，以块为单位申请内存空间。地址空间是一维的

> 只会在最后一个块产生内部碎片

#### 基本概念

- 名词概念

  - 页

    也叫页面，指的是进程中的块。

  - 页框

    也叫页帧，内存块，物理块，物理页面。指的是内存中的块

  - 页框号

    也叫页帧号，内存块号，物理块号，物理页面号。指的是内存中块的编号

  - 块

    也叫盘块。指的是外存中的块

- 地址结构

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011214751975.png" alt="image-20231011214751975" style="zoom:80%;" />

  等式关系：2^(页内偏移量位数)=页面大小，页号位数+页内偏移量位数=系统逻辑位数或地址长度。2^(页号位数)=页面数量。

- 页表

  用于进程的页到内存中的页框的映射。页表由一行一行的页表项组成。页表项存储响应页号的物理块号。物理地址=物理块号*页框大小+页内偏移量。

  > 页表项不存储页号，类比数组下标的概念，因为物理块号大小固定，所以页号隐式指定的

#### 基本地址变换机构

![image-20231011215736511](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011215736511.png)

页面大小为L，逻辑地址A到物理地址E的具体过程

1. 计算页号P=A/L，页内偏移量W=A%L
2. 比较页号P和页表长度M，若P>=M，则产生越界中断，否则继续执行
3. 页号P对应的页表项地址=页表始址F+页号P×页表项长度，取出页表项内容b，即为物理块号
4. 计算物理地址E=b×L+W

> 区分页表长度和页表项长度，页表长度指的是页表一共有多少页号，页表项长度指的是页表中的一页表项占用多大的存储空间。
>
> 内存块数量=页面数量=2^(页表项长度)
>
> 页表项大小和页表项长度是一个意思
>
> 基本地址变换机构至少要访存两次：访问页表+访问内存

#### 具有快表的地址变换机构

![image-20231011221152045](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011221152045.png)

加入快表后，逻辑地址先进入快表中查找（或者快表和内存中的页表中一起查找）

#### 两级页表

也称为顶级页表，页目录表，外层页表。主要为了解决页表要连续型存储而过于占用内存的问题。

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011221909520.png" alt="image-20231011221909520" style="zoom:80%;" />

将页表划分成若干大小的小页表，非连续的装入内存中，建立一个顶级页表存放这些小页表在内存中的内存块号，根据一级页号读取出来小页表后，继续根据二级页号读取出物理块号，结合页内偏移量形成物理地址。

![image-20231011223054648](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231011223054648.png)

> 若采用多级页表机制，规定各级页表最多只能有一个页面
>
> 两级页表访存次数：访问页目录表+访问二级页表+访问内存单元

### 分段管理方式

为了方便编程，便于程序的动态链接和增长，需要将程序分成长度不等的块存入内存，由此提出了分段管理方式。地址空间是二维的。

#### 基本概念

- 分段

  分段方式下要求段内分配连续存储空间，段间不要求连续，逻辑结构如下：

  ![image-20231012112056918](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231012112056918.png)

  段号的位数决定了每个进程最多可以分成多少个段，段内偏移量决定了每个段的最大长度是多少。段号和段内偏移量必须由程序员显式提供。

- 段表

  与页表类似，段表负责逻辑地址到物理地址的映射。每个段表项对应进程中的一段，段表项记录了该段在内存中的始址和长度。

- 段的保护
  - 存取控制保护
  - 地址越界保护
    - 判断段号是否超过段表长
    - 判断段内偏移量是否超过段长

#### 地址变换机构

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231012112726881.png" alt="image-20231012112726881" style="zoom:80%;" />

逻辑地址A到物理地址E的地址变换过程：

1. 比较段号S和段表长度M，若S>=M，则产生越界中断，否则继续执行
2. 段表中段号S对应的段表项地址=段表始址F+段号S×段表项长度，取出该段表项内容，若段内偏移量>=段长C，则产生越界中断，否则继续执行
3. 物理地址E=b+W

### 段页式管理方式

分页式存储管理能够提高内存利用率，分段式存储管理能反映程序逻辑结构并有利于段的共享和保护，两种方式结合起来，形成了段页式管理方式。地址空间是二维的。

#### 基本概念

作业先被分成若干段，段内再分成若干页存储到内存中。段页式系统的逻辑地址结构：

![image-20231012121656731](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231012121656731.png)

> 段号的位数决定了每个进程最多可以分几个段。
>
> 页号的位数决定了每个段最多有多少个页。
>
> 页内偏移量决定了页面/内存块的大小。

#### 地址变换机构

![image-20231012122036216](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231012122036216.png)

一个进程中，段表只能有一个，页表可以有多个。

地址变换的过程：首先通过段表查到页表始址，然后通过页表找到块号，最后形成物理地址，实际上一次访问需要三次访问内存。

## 虚拟内存

- 定义

  基于程序局部性原理，只将运行需要的内容调入内存，这样系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。

- 特征
  - 多次性：程序运行过程中，不是一次性装入内存的，而是分多次装入内存
  - 对换性：程序在运行过程中需要不断地进行内存和外存的对换
  - 虚拟性：是指逻辑上内存被扩大了
- 实现
  - 建立在离散分配的内存管理方式上
  - 请求分页/请求分段/请求段页式存储管理

### 请求分页管理方式

建立在基本分页管理方式上，增加了请求调页功能和页面置换功能。

- 页表机制

  请求分页管理会出现访问的页面不在内存中的情况，因此需要在页表项中增加4个字段。

  ![image-20231017154000281](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231017154000281.png)

  状态位：指示该页是否调入内存

  访问字段：用于记录本页在一段时间内被访问的次数或者最近已有多长时间未被访问，供置换算法参考

  修改位：标识该页在调入内存后是否被修改过，以确定页面置换是否写回外存

  外存地址：指出该页在外存中的地址

- 工作流程：

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231017154535433.png" alt="image-20231017154535433" style="zoom:80%;" />

### 页面分配策略

虚拟内存管理下，操作系统必须决定给特定进程分配几个页框。给一个进程分配的物理页框集合就是这个进程的驻留集。如果分配页面太少可能导致缺页率很高。分配页面太多会降低系统并发度和资源利用率。

- 内存分配策略

  - 固定分配局部置换

    为每个进程分配一定数目的物理块，运行期间不改变。发生页面置换只能从分配该进程的物理块中选出一页，保证分配给该进程的物理块保持不变。

  - 可变分配全局置换

    先为每个进程分配一定数目的物理块，运行期间适当增加或者减少，全局置换指从所有空闲物理块中取出一块置换。

  - 可变分配局部置换

    先为每个进程分配一定数目的物理块，运行期间适当增加或者减少，发生页面置换只能从分配该进程的物理块中选出一页

- 从何处调入页面

  请求分页系统的外存分为：文件区和对换区。对换区采用连续分配方式，文件区采用离散分配方式，因此对换区的磁盘I/O速度更快。不会被修改的文件直接从文件区调入。

### 页面置换策略

当发生页面置换，而此时内存已经无空闲空间时，就需要选择一个调出的页面。

- 最佳(OPT)置换算法

  该算法是选择以后永不使用的页面或者最长时间不再访问的页面，以获得最低的缺页率。但是该算法无法实现。

- 先进先出(FIFO)置换算法

  优先淘汰最早进入内存的页面。

  > FIFO会产生所分配的物理块数增大而页故障数不降反增的异常现象，被称为Belady异常。

- 最近最久未使用(LRU)置换算法

  选择最近最长时间未访问过的页面予以淘汰。

- 时钟(CLOCK)置换算法

  - 简单的时钟CLOCK置换算法

    - 算法步骤
      1. 初始化访问位：为内存中的每个页面设置一个访问位。当页面首次被加载或访问时，将其访问位设置为1。
      2. 形成循环队列：将所有页面组织成一个循环队列，并设置一个替换指针指向队列中的上一次被替换位置的下一页(初始默认指向第一页)。
      3. 页面替换检查：当需要替换页面时，检查当前替换指针指向的页面的访问位。
         - 如果访问位为0，则选择该页面进行替换。
         - 如果访问位为1，则将访问位设置为0，并将替换指针移动到下一个页面。
      4. 循环检查：继续检查下一个页面的访问位，直到找到访问位为0的页面。如果检查到循环队列的最后一个页面，且其访问位为1，则回到队列开始的地方，重新进行循环检查，直到找到可以替换的页面。

  - 改进的时钟CLOCK置换算法

    考虑到如果被替换的页是被修改过的，那么如果将该页替换还需要将该页写回磁盘，磁盘I/O的开销较大。改进的CLOCK算法新增了一个修改位。访问位A和修改位M可以组合成以下四种页面：

    - 1类A=0，M=0：最近未被访问且未被修改，是最佳的淘汰页
    - 2类A=0，M=1：最近未被访问但被修改过，不是很好的淘汰页
    - 3类A=1，M=0：最近已被访问过，但未被修改：可能再被访问
    - 4类A=1，M=1：最近已被访问过且被修改：可能再被访问

    算法步骤如下：

    1. 替换指针从当前位置开始，扫描循环队列，寻找1类页面，将遇到的第一个1类页面作为淘汰页。第一轮扫描不改变访问位A
    2. 第一步失败，则进行第二轮扫描，寻找2类页面，将遇到的第一个2类页面作为淘汰页.第二轮扫描期间将所有扫描过的页面的访问位置0.
    3. 如果第2步也失败，此时所有页面的访问位均已置为0，重复第1和2步，此时一定能找到被淘汰的页面。

### 抖动

刚刚换入的页面马上就要换出主存，这种频繁的页面调度称为抖动或者颠簸。

产生的根本原因是进程频繁访问的页面数量多于分配的物理页面数量(分配给进程的物理块不够)

### 工作集

指某段时间间隔内，进程实际访问页面的集合。具体的计算方法如下：

![image-20231017162114161](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231017162114161.png)

工作集反映了接下来一段时间内很有可能会频繁访问的页面集合。一般来说分配给进程的物理块数(驻留集大小)要大于工作集大小。