---
title: 进程与线程
date: 2023-07-29 11:14 
categories:
- 计算机基础
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>



## 进程

- 概念

  一个进程实体或进程映像是由程序段，数据段和PCB三部分组成。进程是进程实体的运行过程，是系统进行资源分配和调度的独立单位。

  > PCB(Process Control Block)：进程控制块，用于描述进程的基本信息和状态的内存块，是进程存在的唯一标志

- 特征
  - 动态性：进程的状态是不断变化的
  - 并发性：允许多个进程并发执行
  - 独立性：进程独立接受CPU资源分配和调度
  - 异步性：进程的执行速度是不可预知的

- 进程的映像(process image)

  - 代码段：程序的二进制代码，代码段是只读的，可以被多个进程共享
  - 数据段：全局变量和静态变量
  - 进程控制块PCB
  - 堆：存放动态分配的变量(malloc函数)
  - 栈：存放和实现函数调用相关信息


## 进程的状态及转换

![image-20230928221659886](https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230928221659886.png)

- 创建态(新建态)：进程创建的过程，包括填写PCB，分配资源等

- 就绪态：当进程获得了一切资源，但还没有获得CPU调度，就进入了就绪态

- 运行态：获得CPU调度的进程

- 阻塞态(等待态)：运行态的进程需要等待某资源可用(除了CPU)，例如I/O，进程进入阻塞态，获得资源后重新进入就绪态等待调度

  > 进程通常通过系统调用的方式从运行态转变为阻塞态
  >
  > 运行态->阻塞态是主动行为，阻塞态->就绪态是被动行为

- 终止态：进程正常或异常退出的状态

## 进程控制

进程控制即实现进程状态转换的具体操作，一般通过原语实现，原语执行过程不允许中断。

- 创建原语

- 阻塞(Block)原语：阻塞正在进行的进程，并且保护其现场

- 唤醒(Wakeup)原语：将阻塞态的进程唤醒，将其加入就绪态

  阻塞原语和唤醒原语必须成对使用

## 线程

- 概念

  线程是进程中的一个实体，线程自己几乎并不拥有系统资源，只拥有一点运行必不可少的资源，它可与同一进程的其他线程共享进程拥有的全部资源。

  线程可以创建和撤销另一个线程，多个线程可以并发执行，线程运行也有状态。

- 和进程的比较

  - 调度方面：同一进程下的线程切换不会引起进程切换，不同进程下的线程切换则会，平均来说线程切换的代价远低于进程
  - 并发性：线程和进程都有并发执行的能力
  - 拥有资源：进程是系统中拥有资源的基本单位，而线程几乎不拥有系统资源
  - 独立性：进程由独立的地址空间和资源，而线程不具有，同一进程的不同线程共享进程的资源

- 实现方法

  - 用户级线程

    <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230929143314216.png" alt="image-20230929143314216" style="zoom:67%;" />

    线程相关的所有工作都由应用程序在用户空间完成，内核意识不到线程存在。

    优点：线程切换不需要到内核空间，开销小

    缺点：一个线程被阻塞，相同进程下的其他线程都暂停；内核每次被分配的只有众多线程中的一个，不能发挥多CPU优势

  - 内核级线程

    <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230929143623706.png" alt="image-20230929143623706" style="zoom:67%;" />

    线程相关的所有工作都在内核空间里完成。

    优点：能发挥多CPU优势，系统执行效率高

    缺点：线程切换需要从用户态转到内核态，开销较大

  - 组合方式

    <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230929143858697.png" alt="image-20230929143858697" style="zoom:67%;" />

    综合上面两个方法的优点。

## 多线程模型

对于线程的组合实现方式，由于用户级线程和内核级线程的连接不同，形成以下三种不同的多线程模型：

- 多对一模型

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230929144225651.png" alt="image-20230929144225651" style="zoom:67%;" />

  其实就是组合方式退化成了用户级线程

- 一对一模型

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20230929144259222.png" alt="image-20230929144259222" style="zoom:67%;" />

  即组合方式退化成了内核级线程

- 多对多模型

  将n个用户级线程映射到m个内核级线程上(n>=m)

# 处理机调度

## 调度的概念

即按照一定的算法选择一个进程并进行处理机分配的过程

- 层次

  - 高级调度(作业调度)

    从外存/辅存的后备队列中选择一个作业调入内存的就绪队列

  - 中级调度(内存调度)

    从外存的挂起队列中选择一个进程调入内存的就绪队列

    > 当内存不够用时，可以将暂时不能运行的进程调入外存的挂起队列中，提高内存利用率

  - 低级调度(进程调度)

    从内存的就绪队列中选择一个进程分配处理机资源

- 三级调度联系

  高级->中级->低级，调度次数依次增加

- 调度时机
  - 应该进行进程调度：
    - 当前进程无法继续下去，对应非剥夺式调度
    - 中断处理结束或自陷结束后，对应剥夺式调度
  - 不应该进行进程调度：
    - 处理中断过程中
    - 进程再操作系统内核临界区(加锁)
    - 进程执行原子操作过程中

## 性能指标

- CPU利用率
  $$
  CPU利用率=\frac{CPU工作时间}{CPU工作时间+CPU等待时间}
  $$

- 系统吞吐量

  单位时间CPU完成作业数量

  > 短作业需要消耗的CPU时间短，故能提高系统吞吐量

- 周转时间
  $$
  周转时间=作业完成时间-作业提交时间
  $$
  也可以用如下公式计算：
  $$
  对于计算型任务：周转时间=等待时间+运行时间
  \\对于I/O密集型任务:周转时间=等待时间+运行时间+I/O操作时间
  $$

- 平均周转时间

  各作业周转时间的平均值

- **带权周转时间**
  $$
  带权周转时间=\frac{作业周转时间}{作业运行时间}
  $$

- 平均带权周转时间

  各作业带权周转时间的平均值

- 响应时间

  作业提交到系统产生响应的时间

## 调度算法

### 先来先服务(FCFS)调度算法

即CPU调度按照进程到来的先后顺序。非抢占式。非交互式。

缺点：不利于短作业，效率低。有利于CPU繁忙型，不利于I/O繁忙型

### 短作业优先(SJF)调度算法

即CPU调度按照作业预计运行时间的长度，先运行短作业。**默认非抢占式**。非交互式

> 抢占式的SJF又称为最短剩余时间优先算法SRTF

缺点：对长作业不利，容易造成长作业饥饿甚至饿死

优点：相比于其他算法，SJF可以获得较少的平均等待时间和平均周转时间

### 优先级调度算法

即CPU调度按照就绪队列中作业的优先级。既可以是抢占式也可以是非抢占式。交互式。

- 非抢占式。一个进程在CPU上运行，此时即使有一个优先级更高的进程到来，也不让出CPU
- 抢占式。在上述的情况下，让出CPU

> 优先级：
>
> - I/O型进程 > 计算型进程
>
>   因为CPU可以和I/O设备并行运行，I/O型进程可以让I/O设备尽早工作，同时CPU还可以运行其他进程，提高系统效率
>
> - 系统进程 > 用户进程
>
> - 交互型进程 > 非交互型进程(或前台进程 > 后台进程)

### 时间片轮转调度算法

即按FCFS的策略按顺序依次给每个进程分配一个时间片。交互式

- 时间片很大：则几乎所有进程都能在一个时间片完成，就退化为了先来先服务调度算法
- 时间片很小：处理机频繁调度，开销增大

### 多级反馈队列调度算法

<img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231004164540788.png" alt="image-20231004164540788" style="zoom:80%;" />

融合了前面几种算法的优点，实现思想如下：

- 设置多个就绪队列，第1级队列优先级最高，后面的队列优先级逐个降低
- 每个队列所分配的时间片大小各不相同，优先级越高的队列，时间片越短
- 每个队列采用FCFS算法，新进程按照FCFS等待调度，轮到该进程执行时，如它能在时间片内完成，即可撤离；否则将其加入下一级队列的队尾中，最后一级队列不会再被下调，重新插入最后一级队列末尾
- 按队列优先级调度，只有第1~i-1级队列均空时，才调度第i级队列的进程。若处理机调度第i级队列中，又有新进程进入优先级更高的队列中，则必须把正在运行的进程放回第i级队列的末尾，CPU分配给新到的高优先级进程

# 同步与互斥

## 基本概念

- 进程同步

  即进程间有直接制约，进程间有执行顺序

- 临界资源

  即一次仅允许一个进程使用的资源

- 临界区

  进程中访问临界资源的代码段

- 进程互斥

  不允许多个进程的临界区访问临界资源

- 同步与互斥机制原则
  - 空闲让进：当临界资源空闲，允许一个进程进入临界区
  - 忙则等待：当临界资源被占用，其他进程应当等待
  - 有限等待：在等待的进程应当在有限时间内进入临界区
  - 让权等待：当进程不能进入临界区时，应当释放CPU，防止进程忙等待

## 实现临界区互斥的方法

- 软件实现方法

  在进入区的代码处设置一些标志。

  - 单标志法

    设置公用变量turn=0

    ```cpp
    //P0进程
    while(turn!=0);
    //访问临界区
    turn=1;
    //退出
    ```

    ```c#
    //P1进程
    while(turn!=1);
    //访问临界区
    turn=0;
    //退出
    ```

    

    缺点：两个进程必须交替进入临界区，某个进程不再进入临界区，则另一个进程也无法进入，违背"空闲让进"

  - 双标志先检查法

    设置布尔数组flag[]，flag[i]=FALSE表示进程未进入临界区，flag[i]=TRUE表示进程已经进入临界区

    ```c#
    //P0进程
    while(flag[1]);
    flag[0]=true;
    //访问临界区
    //退出
    flag[0]=false;
    ```

    ```bash
    //P1进程
    while(flag[0]);
    flag[1]=true;
    //访问临界区
    //退出
    flag[1]=false;
    ```

    优点：不用交替使用

    缺点：若有两个进程同时进入while判断，则都会跳出循环访问临界区，违背"忙则等待"

  - 双标志后检查法

    同样设置布尔数组flag[]，把flag[]的检查放到后面

    ```basic
    //P0进程
    flag[0]=true;
    while(flag[1]);
    //访问临界区
    //退出
    flag[0]=false;
    ```

    ```c
    //P1进程
    flag[1]=true;
    while(flag[0]);
    //访问临界区
    //退出
    flag[1]=false;
    ```

    缺点：如果两个进程同时想进入临界区，都将自己的flag设置为true，则两个进程会出现"饥饿"，谁都无法访问临界区，违背"空闲让进"

  - Peterson's Algorithm

    设置flag[]数组一个和turn变量，并且采用后检查

    ```cassandra
    //P0进程
    flag[0]=true;
    turn=0;
    while(flag[1]&&turn==1);
    //访问临界区
    //退出
    flag[0]=false;
    ```

    ```ceylon
    //P1进程
    flag[1]=true;
    turn=1;
    while(flag[0]&&turn==0);
    //访问临界区
    //退出
    flag[1]=false;
    ```

    优点：解决了进程的互斥访问

    缺点：如果一个进程不能立刻进入临界区，会一直占用CPU，违背"让权等待"，实际上所有的软件实现方法都没有完成"让权等待"

- 硬件实现方法

  - 中断屏蔽法

    加入关中断机制，防止在进程访问临界区时出现进程切换

    缺点：提高系统风险性

  - 硬件指令法

    常见的有TestAndSet指令(TS指令)和Swap指令。

    优点：由于是原子操作，无需严格检查逻辑漏洞，实现简单

    缺点：所有的硬件实现方法也都没有完成"让权等待"

## 信号量

使用"P"操作和"V操作"解决同步和互斥问题

> "P"操作和"V操作"都是低级进程通信原语

- 实现同步

  设S为实现进程P1和P2同步的公共信号量，初值为0

  ```cmake
  //假设要先执行x语句再执行y语句
  semaphore S=0;
  P1(){
  ...
  x; 
  V(S); //x语句已经执行完毕 
  ...
  }
  P2(){
  ...
  P(S); //检查语句x是否已经运行完成
  y; //若无误则运行y语句
  }
  ```

- 实现互斥

  ```coffeescript
  //假设语句
  semaphore S=n; //n表示临界资源的数量
  P1(){
      ...
      P(S);
      ...  //访问临界资源
      V(S);
  }
  P2(){
      ...
      P(S);
      ...  //访问临界资源
      V(S);
  }
  ```

- 实现前驱关系

  假设有如下程序的前驱图，使用信号量来控制它们之间的执行顺序(只写出PV操作，忽略其他执行代码)

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231007172412060.png" alt="image-20231007172412060" style="zoom: 67%;float:left" />

  ```cmake
  semaphore S1=S2=S3=S4=S5=0;
  P1(){
  V(S1)
  }
  P2(){
  P(S1)
  V(S2)
  }
  P3(){
  P(S1)
  V(S3)
  }
  P4(){
  P(S2)
  V(S4)
  }
  P5(){
  P(S2)
  V(S5)
  }
  P6(){
  P(S4)
  P(S5)
  P(S3)
  }
  ```

## 经典同步与互斥问题

### 单生产者-单消费者

- 问题描述：一个初始为空，长度为n的缓冲区，生产者一次能往其中放一个消息，消费者一次能从中读出一个消息。生产者和消费者必须互斥的访问缓冲区。缓冲区没满时，生产者才可以放消息。缓冲区没空时，消费者才可以读消息。

- 问题分析

  - 互斥：缓冲区；mutex
  - 同步：生产者和消费者；full和empty

- 问题解决

  ```csharp
  //定义信号量
  semaphore mutex=1;
  semaphore empty=n, full=0;
  ```

  ```CQL
  //生产者进程
  processor(){
  P(empty); //缓冲区不满，可以放入
  P(mutex); //互斥访问缓冲区
  //放入消息
  V(mutex); //释放缓冲区
  V(full); //缓冲区消息量+1
  }
  ```

  ```cmake
  //消费者进程
  consumer(){
  P(full); //缓冲区不空，可以读出
  P(mutex); //互斥访问缓冲区
  //读出消息
  V(mutex); //释放缓冲区
  V(empty); //缓冲区消息量-1
  }
  ```

  

### 多生产者-多消费者

- 问题描述：桌上有一个盘子，每次只能往其中放入一个水果，爸爸专门向盘中放苹果，妈妈专门放橘子。儿子专等吃橘子，女儿专等吃苹果。只有盘子不空时，才可以放水果。

- 问题分析

  - 互斥：盘子
  - 同步：爸爸-女儿；妈妈-儿子

- 问题解决

  ```D
  //定义信号量
  semaphore plate=1,apple=0,orange=0;
  ```

  ```dart
  //爸爸进程
  Dad(){
      P(plate);
      //放苹果
      V(plate);
      V(apple);
  }
  ```

  ```cmake
  //妈妈进程
  Mom(){
  P(plate);
  //放橘子
  V(plate);
  V(orange);
  }
  ```

  ```cmake
  //儿子进程
  Son(){
  P(orange);
  P(plate);
  //吃橘子
  V(plate);
  }
  ```

  ```cmake
  //女儿进程
  Daughter(){
  P(apple);
  P(plate);
  //吃苹果
  V(plate);
  }
  ```

  

### 抽烟者问题

- 问题描述：有三个抽烟者和一个供应者，抽烟需要三个原材料A,B,C，三个抽烟者分别拥有AB,AC,BC，供应者每次随机将A,B,C中的一个原材料放到桌上，正好缺这种材料的抽烟者拿掉它并卷一个烟抽掉。供应者会让三个抽烟者轮流吸烟，且所有人自己拥有的材料是无限的

- 问题分析

  - 互斥：原材料
  - 同步：抽烟者-供应者

- 问题解决

  ```dtd
  //定义信号量
  semaphore A=0,B=0,C=0;
  semaphore mutex=1;
  int i=0;
  ```

  ```dylan
  //供应者进程
  provider(){
      while(1){
          P(mutex);
          if((i++)%3==0) V(A);
          if((i++)%3==1) V(B);
          if((i++)%3==2) V(C);
          V(mutex);
      }
  }
  ```

  ```ejs
  //抽烟者1进程
  smoker1(){
      while(1){
          P(A);
          P(mutex);
          //吸烟
          V(mutex);
      }
  }
  //抽烟者2进程
  smoker2(){
      while(1){
          P(B);
          P(mutex);
          //吸烟
          V(mutex);
      }
  }
  //抽烟者3进程
  smoker3(){
      while(1){
          P(C);
          P(mutex);
          //吸烟
          V(mutex);
      }
  }
  ```

  

### 读者-写者问题

- 问题描述：有多个读者和写者共享一个文件，要求：允许多个读者对文件进行读操作；同时只允许一个写者往文件写信息；任意一个写者在完成写操作前，其他读者或写者不允许操作文件；写者在写文件时，已有的读者和写者应全部退出。

- 问题分析

  - 互斥：写者和读者
  - 同步：无

- 问题解决

  读进程优先：

  ```dtd
  //定义信号量
  int count=0;
  semaphore mutex=1;//对count变量的互斥访问
  ```

  ```elm
  //读者i进程
  reader_i(){
  P(mutex)
  count++;
  V(mutex);
  //读文件
  //退出
  P(mutex)
  count--;
  V(mutex);
  }
  ```

  ```elixir
  //写者j进程
  writer_j(){
  if(count==0){
  	P(mutex); //只允许一个写进程访问资源
  	//写文件
  	V(mutex);
  }
  }
  ```

  

### 哲学家进餐问题

- 问题描述：一张圆桌坐着5名哲学家，每两名哲学家之间摆一只筷子，哲学家只在思考时，不影响他人；当哲学家饥饿时，试图拿起左、右两根筷子(分开拿)，若筷子已在他人手上，则需要等待，只有同时拿到两根筷子才可以进餐。

- 问题分析

  - 互斥：筷子
  - 同步：无

- 问题解决

  可采用只有左右两根筷子都同时可以拿的时候，才允许该哲学家吃饭

  ```erb
  //定义信号量
  semaphore chopstick[]={1,1,1,1,1}, mutex=1;
  ```

  ```cmake
  //哲学家i进程
  philosopher_i(){
  P(mutex);
  P(chostick[i]);
  P(chopstick[(i+1)%5]);
  V(mutex);
  //吃饭
  V(chostick[i]);
  V(chopstick[(i+1)%5]);
  }
  ```

# 死锁

## 概念

- 定义

  即多个进程因竞争不可剥夺资源而形成的互相等待的局面，若无外力作用，所有进程都将无法向前推进

- **死锁产生的四个必要条件(真题考过)**

  - 互斥条件：所竞争的资源只能同时只能由一个进程所占用
  - 不剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程强行夺走
  - 请求并保持条件：进程提出新的请求，并对自己拥有的资源保持不放
  - 循环等待条件：存在一个循环等待链，每个进程同时申请链中下一进程所占有的资源

  > 只有每类资源只有一个的含圈资源分配图才一定有死锁

## 处理策略

死锁的处理策略有以下三类：

### 死锁预防

破坏四个必要条件中的一个，是一种非常保守的策略，效率低。

根据破坏不同的必要条件，死锁预防有以下四种具体操作：

- 破坏"互斥条件"

  不太现实，一般的临界资源只能互斥使用

- 破环"不剥夺条件"

  允许系统剥夺死锁中某进程的资源。

  策略实现比较复杂，反复剥夺进程资源降低效率

- 破坏"请求并保持条件"

  采用预先静态分配的方法，即进程在运行前一次申请完它所需要的全部资源，一旦投入运行，不允许进程再申请资源

- 破坏"循环等待条件"

  给系统的资源编号，进程必须按资源编号递增的顺序请求资源，实现复杂且容易造成资源浪费

### 死锁避免

资源动态分配过程中，防止系统进入不安全(死锁)状态，是一种较保守较高效的策略。

- 系统安全状态

  是指系统按照某进程序列推进执行时，序列的每个进程都可以顺利完成，这种情况的序列称为安全序列，系统处于安全状态

  > 系统处于安全状态，一定无死锁发生。但是系统处于不安全状态不一定代表一定有死锁进程。
  >
  > 因为无安全序列的原因是进程不足以满足分配，但并不代表一定会出现所有进程都占着资源阻塞的死锁状态。

- 银行家算法

  进程在执行中申请资源时，先测试可用资源是否足以分配，若能分配再继续试探其他等待进程，看能否找到安全序列。

  - 数据结构描述

    - 可利用资源向量Available：当前系统可分配资源向量

    - 最大需求向量矩阵Max：各进程对资源的最大需求

    - 分配矩阵Allocation：系统已分配给各进程的资源情况

    - 需求矩阵Need：各进程运行还需要的资源情况

      > Need = Max - Allocation

  - 算法描述

    某进程i向系统发出资源请求向量Request_i，系统开始执行算法：

    1. Request_i超过了Need_i或者超过了Available，出错退出，否则进入步骤2

    2. 系统给进程i分配资源，并将进程i加入安全序列尾。

       Available=Available-Request_i；

       Need_i=Need_i-Request_i

       Allocation=Allocation+Request_i

    3. 从所有等待进程中找到满足Need_j<Available的进程，试探性加入安全序列，并且

       Available=Available+Allocation_j

       重复步骤3，知道找不到满足要求的进程

    4. 如果此时还有进程处于等待状态，则系统处于不安全状态，否则系统处于安全状态，生成一个安全序列。

### 死锁检测和解除

允许进程在运行时发生死锁，发生死锁并检测出后，用某种措施解除死锁。是一种非常宽松的策略。

- 资源分配图

  <img src="https://gitee.com/Marches7/piture-bed/raw/master/img/image-20231009175219558.png" alt="image-20231009175219558" style="zoom:50%;float:left" />

  当前所有进程及其使用资源的情况可以用资源分配图描述，**圆圈**代表进程，**框**代表一类资源，框内一个圆代表一类资源中的一个资源，资源**请求边**由进程指向资源，一条边代表申请一个该类资源；资源**分配边**由资源指向边，一条边表示该类资源被分配一个给进程。

- 死锁定理

  基于资源分配图，死锁定理可用于判断系统是否处于死锁，简而言之即依次消除与不阻塞进程相连的边，直到无边可消。所谓不阻塞进程即该进程申请的资源，系统有余。

  当无边可消后，若不能消去图中所有的边，则称该图是不可完全简化的，系统处于死锁状态。

- 解除死锁
  - 资源剥夺法：剥夺某些死锁进程的资源并分配给其他进程
  - 撤销进程法：强制撤销部分甚至所有进程
  - 进程回退法：让一个或多个进程回退到足以避免死锁的地步，进程回退时自愿释放资源而非被剥夺。

# 提高部分

## fork()函数

- 定义

  一个进程(程序)，可以用fork()创建一个子进程，当子进程创建时，系统给新进程分配资源，例如存储数据和代码的空间，然后把原来的进程的所有值都复制给新的进程中，子进程**从fork()的返回处**开始执行与父进程相同的代码。

- 特点

  - fork()函数调用一次，返回两次。在父进程中返回子进程的pid(非0值)，在子进程中返回0
  - fork()之后，父进程和子进程执行代码的顺序是不一定的，这个和内核调度算法有关

- fork函数的返回值

  - 在父进程中，fork函数返回新创建子进程的PID
  - 在子进程中，fork函数返回0
  - 如果出现错误，fork函数返回一个负值

- 示例

  1.

  ```cpp
  #include <iostream>
  #include <unistd.h>
  #include <sys/types.h>
  using namespace std;
  int main(){
          if(fork()||fork()){
                  cout<<'A'<<endl;
  
          }
          else{
                  cout<<'B'<<endl;
          }
          return 0;
  }
  ```

  输出：两个A一个B

  2.

  ```c
  #include<stdio.h>
  #include<unistd.h>
  #include<sys/types.h>
  int main(){
          for(int i=0;i<2;i++){
                  if(fork()==0)
                          printf("A\n");
                  else
                          printf("B\n");
  
          }
  }
  ```

  输出：三个A三个B

  3.

  ```c
  #include<stdio.h>
  #include<unistd.h>
  #include<sys/types.h>
  int main(){
          for(int i=0;i<3;i++){
                  if(i==1)
                          fork();
                  printf("%d\n", i);
          }
  }
  ```

  输出01212（输出顺序可能不同）

  > 注意一定要把每个进程都执行完毕!
