---
title: Java实用技能
date: 2024-08-06 17:49 
categories:
- Java笔记
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>


# 日期与时间

Java标准库中有新旧两套处理日期和时间的API：

- 旧API：定义在`java.util`中，主要包括`Date`，`Calendar`和`TimeZone`这几个类
- 新API：定义在`java.time`中，主要包括`LocalDateTime`，`ZonedDateTime`和`ZondeId`等

我们应坚持使用新API，旧的API因为历史遗留问题，也要过渡到新API使用。

- LocalDateTime

  获取当前日期与时间，默认按照ISO 8681规定的格式打印

  ```java
  LocalDateTime dt = LocalDateTime.now(); 
  ```

  如果要自定义格式化，则需要使用`DateTimeFormatter`库

  ```java
  DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
  System.out.println(dtf.format(LocalDateTime.now()));
  ```

  对日期就可以进行加减，并且支持链式调用

  ```java
  LocalDateTime dt2 = dt.plusDay(5).minusHours(3);
  ```

- ZonedDateTime

  `LocalDateTime`总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要`ZonedDateTime`。

  获取默认时区和指定时区的时间：

  ```java
  ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
  ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York"));
  ```

  也可以通过给一个`LocalDateTime`加一个`ZoneId`参数，变成`ZonedDateTime`：

  ```java
  ZonedDateTime zbj = dt.atZone(ZoneId.of("America/New_York"));
  ```

  时区转换可以使用`withZoneSameInstant()`，下面展示了将中国时区的时间转换成纽约时间：

  ```java
  ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of("Asia/Shanghai"));
  ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of("America/New_York"));
  ```

  > [!CAUTION]
  >
  > 涉及到时区转换时，不要自己计算时差，否则很难正确处理夏令时

- Instant

  计算机存储的当前时间，实际上就是一个不断递增的整数。从1970年1月1日的格林威治时间为0，逐秒递增。

  返回当前计算机的时间戳：

  ```java
  System.out.println(System.currentTimeMillis());
  ```

  该时间戳在`java.time`中以`Instant`表示，也可以用`Instant.now()`获取当前的时间戳：

  ```java
  Instant now = Instant.now();
  System.out.println(now.getEpochSecond()); // 精确到秒
  ```

  使用时间戳常见当前时区的`ZonedDateTime`：

  ```java
  ZonedDateTime = now.atZone(ZoneId.systemDefault());
  ```

- 新旧API的转换：

  通过中间变量`Instant`对象即可实现转换。



# 单元测试

- 定义

  单元测试即针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此针对Java程序进行的单元测试就是针对单个Java方法的测试。

- JUnit

  JUnit是一个广泛使用的，专为Java设计的单元测试框架。下面是一个简单判等的测试。

  ```java
  import static org.junit.jupiter.api.Assertions.*;
  import org.junit.jupiter.api.Test;
  
  public class FactorialTest{
      @Test
      void testFact() {
          assertEquals(1, Factorial.fact(1));
      }
  }
  ```

  > [!TIP]
  >
  > 每个`@Test`方法内部的成员变量都是独立的。

- 测试编写规范

  1. 单元测试本身必须非常简单，看一下就能明白，绝不能再为测试代码编写测试
  2. 每个单元测试应当相互独立，互不干扰
  3. 测试时不但要覆盖常用的测试用例，还要特别注意测试边界条件。

- Fixture方法

  在测试时，我们经常遇到一个对象需要初始化，测试完还需要清理，如果每个`@Test`方法都写一遍重复代码，会显得比较麻烦。Fixture方法是为了给JUnit提供测试前准备，测试后清理的固定代码。

  - `@BeforeEach`和`@AfterEach`

    `@BeforeEach`用来初始化，`@AfterEach`用于清理资源。分别位于每个`@Test`方法的前后自动运行。

    ```java
    public class CalculatorTest {
        Calculator calculator
        
        @BeforeEach
        public void setUp() {
            this.calculator = new Calculator();
        }
        
        @AfterEach
        public void tearDown() {
            this.calculator = null;
        }
        
        @Test
        void test() {
            assertEquals(100, this.calculator.add(100));
        }
        
        @Test
        void test() {
            assertEquals(200, this.calculator.add(200));
        }
    }
    ```

  - `@BeforeAll`和`@AfterAll`

    当一些资源的初始化和清理更加繁琐，JUnit提供了`@BeforeAll`和`@AfterAll`，它们运行在**所有的**`@Test`的前后，且仅运行一次，因此它们只能初始化静态变量。

- 异常测试

  测试不仅要处理方法正确输出的情况，当方法出现错误时（抛出异常），测试也要涵盖到。因此对可能抛出的异常进行测试被称为异常测试。

  下面这个例子展示了一个测试捕获的异常的例子：

  ```java
  @Test
  void testNegative() {
      assertThrows(IllegalArgumentException.class, new Executable() {
          @Override
          public void execute() throws Throwable {
              Factorial.fact(-1);
          }
      });
  }
  ```

  JUnit提供了`assertThrows()`来期望捕获一个指定的异常，第二个参数使用匿名内部类封装要执行测试的代码。`assertThrows()`在捕获到异常时通过测试，为捕获到异常或者异常类型不对时，均表示测试失败。

- 条件测试

  当运行测试时，我们希望部分测试代码只针对某些具体的条件执行，例如一个方法的源代码针对Windows和Mac分别做了个性化解决方案，测试代码希望在Windows平台只运行针对Windows平台的测试代码，Mac平台同理。这样的给测试代码添加条件的方法称为条件测试。下面展示了一个针对Windows平台和Mac平台的测试代码。

  ```java
  @Test
  @EnabledOnOs(OS.WINDOWS)
  void testWindows() {
      assertEquals("C:\\test.ini", config.getConfigFile("test.ini"));
  }
  
  @Test
  @EnabledOnOs({ OS.LINUX, OS.MAC })
  void testLinuxAndMac() {
      assertEquals("/usr/local/test.cfg", config.getConfigFile("test.cfg"));
  }
  ```

  `@EnableOnOs`就是一个条件判断。

  还有一些其他的条件判断：

  - 只能在Java 9或更高版本执行的测试：`@DisabledOnJre(JRE.JAVA_8)`
  - 只能在64位操作系统上执行的测试：`@EnabledIfSystemProperty`

- 参数化测试

  将测试数据从代码中解放出来，代码中的输入和输出定义为参数，这种测试方法被称为参数化测试。JUnit提供了`@ParameterizedTest`注解结合各种参数源注解（如`@ValueSource`），用于参数化测试。

  ```java
  @ParameterizedTest
  @ValueSource(ints = { 0, 1, 5, 100 })
  void testAbs(int x) {
      assertEquals(x, Math.abs(x));
  }
  ```

  
# 正则表达式

- 定义

  如果想要判断一个字符串是否符合某个固定格式，通过撰写代码来逻辑判断显得过于复杂。正则表达式就是一个描述规则的字符串，所以只要编写正确的规则，就可以判断字符串是否合理。

- 使用

  例如"\d"代表匹配任意一个数字，但是在Java中 `\` 是一个转义字符，需要使用双反斜杠`\\`来表示单个反斜杠。

- 匹配规则

| 目标字符串               | 匹配规则                                        |
| ------------------------ | ----------------------------------------------- |
| 非ASCII字符              | `\u####`（十六机制），例如`\u548`匹配字符串`和` |
| 任意字符                 | `.`                                             |
| 单个数字                 | `\d`                                            |
| 一个字母或下划线         | `\w`                                            |
| 一个空格字符/一个Tab字符 | `\s`                                            |
| 单个非数字               | `\D`                                            |
| 单个非字母或下划线       | `\W`                                            |
| 单个非空格字符           | `\S`                                            |

- 重复匹配规则

​	如果需要多次匹配，例如匹配多个数字，就要用到重复匹配规则，直接加在后面。

| 目标重复次数     | 重复匹配规则   |
| ---------------- | -------------- |
| 任意个（0~无穷） | `*`，例如`\d*` |
| 至少一个         | `+`            |
| 0个或一个        | `?`            |
| 精确匹配n个字符  | `{3}`          |
| 匹配n~m个字符    | `{n,m}`        |
| 至少n个字符      | `{n,}`         |

- 复杂匹配规则

| 目标规则                               | 复杂匹配规则              |
| -------------------------------------- | ------------------------- |
| 以...开头的字符串                      | `^`，例如`^\d{3}`         |
| 以...结尾的字符串                      | `$`，例如`\d{3}$`         |
| 匹配一定范围的单个字符                 | `[...]`，例如[1-9]，[a-z] |
| 匹配不包括一定范围的单个字符的其他字符 | `[^...]`，例如\[^1-9]     |
| 或规则                                 | `|`                       |
| 分组                                   | `()`                      |

> 注意不要理解错[10-23]，他不是匹配10~23的数，而是匹配
>
> - 1
> - 0~2
> - 3
>
> 上述三个类别中任意一个数字，综合起来也就是匹配0~3的单个数字

- 分组匹配

  分组匹配可以方便我们提取不同组的子串。例如电话号码匹配串`(\d{3,4})-(\d{6,8})`可以方便我们快速提取区号和电话号。例子如下：

  ```java
  import java.util.regex.*;
  
  public class Main {
      public static void main(String[] args) {
          Pattern p = Pattern.compile("(\d{3,4})\-(\d{6,8})");
          Matcher m = p.matcher("010-12345678");
          if (m.matches()) {
              String g1 = m.group(1);
              String g2 = m.group(2);
              System.out.println(g1);
              System.out.println(g2);
          }
          else {
              System.out.println("匹配失败");
          }
      }
  }
  ```

  上述代码首先用`Pattern`对象匹配正则表达式，匹配后获得一个`Matcher`对象，如果匹配成功，就可以直接从`Matcher.group(index)`返回子串，index为0表示整个字符串，index为1表示第一个子串，inde为2表示第二个子串。

- 非贪婪匹配

  正则表达式默认采用的贪婪匹配的方式，即从左到右尽可能匹配多的字符，如果我们想要其匹配尽可能少的字符，就需要非贪婪匹配的方式。

  例如给定一串数字，判断该数字末尾的个数，"123000"有3个0。可以很容易写出表达式(\d+)(0*)，然后通`Pattern`和`Matcher`去识别提取。

  然而由于贪婪匹配，第一组的\d+就会匹配掉所有的数字，导致第二个子串始终为空串。

  所以我们要让\d+尽量少匹配，0*尽量多匹配，也即让\d+采用非贪婪匹配，在\d+后面添加个`?`即可表示非贪婪匹配。总的表达式为(\d+?)(0\*)

  再例如：这个正则表达式`(\d??)(9*)`，注意`\d?`表示匹配0个或1个数字，后面第二个`?`表示非贪婪匹配，因此，给定字符串`"9999"`，匹配到的两个子串分别是`""`和`"9999"`，因为对于`\d?`来说，可以匹配1个`9`，也可以匹配0个`9`，但是因为后面的`?`表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个`9`。

- 分割字符串

  ```java
  "a b c".split("\\s"); // { "a", "b", "c" }
  "a b  c".split("\\s"); // { "a", "b", "", "c" }
  "a,b ;; c".split("[\\,\\;\\s]+"); // { "a", "b", "c" }
  ```

- 替换字符串

  使用正则表达式替换字符串可以直接调用`String.replaceAll`，第一个参数是正则表达式，第二个参数是待替换的字符串。

  ```java
  String s = "The     quick\t\t brown   fox  jumps   over the  lazy dog.";
  String r = s.replaceAll("\\s+", " ");
  System.out.println(r); // "The quick brown fox jumps over the lazy dog."
  ```

- 反向引用

  `String.replaceAll()`传入的第二个参数可以使用`$1`，`$2`等来反向引用到匹配的子串。$1代表分组匹配的第一组，$2代表第二组。

  ```java
  String s = "the quick brown fox jumps over the lazy dog.";
  String r = s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
  System.out.println(r); // the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.
  ```
  









