---
title: Java实用技能
date: 2024-08-06 17:49 
categories:
- Java笔记
tags:
---
<head>
  <meta name="referrer" content="no-referrer" />
</head>


# 日期与时间

Java标准库中有新旧两套处理日期和时间的API：

- 旧API：定义在`java.util`中，主要包括`Date`，`Calendar`和`TimeZone`这几个类
- 新API：定义在`java.time`中，主要包括`LocalDateTime`，`ZonedDateTime`和`ZondeId`等

我们应坚持使用新API，旧的API因为历史遗留问题，也要过渡到新API使用。

- LocalDateTime

  获取当前日期与时间，默认按照ISO 8681规定的格式打印

  ```java
  LocalDateTime dt = LocalDateTime.now(); 
  ```

  如果要自定义格式化，则需要使用`DateTimeFormatter`库

  ```java
  DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
  System.out.println(dtf.format(LocalDateTime.now()));
  ```

  对日期就可以进行加减，并且支持链式调用

  ```java
  LocalDateTime dt2 = dt.plusDay(5).minusHours(3);
  ```

- ZonedDateTime

  `LocalDateTime`总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要`ZonedDateTime`。

  获取默认时区和指定时区的时间：

  ```java
  ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区
  ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York"));
  ```

  也可以通过给一个`LocalDateTime`加一个`ZoneId`参数，变成`ZonedDateTime`：

  ```java
  ZonedDateTime zbj = dt.atZone(ZoneId.of("America/New_York"));
  ```

  时区转换可以使用`withZoneSameInstant()`，下面展示了将中国时区的时间转换成纽约时间：

  ```java
  ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of("Asia/Shanghai"));
  ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of("America/New_York"));
  ```

  > [!CAUTION]
  >
  > 涉及到时区转换时，不要自己计算时差，否则很难正确处理夏令时

- Instant

  计算机存储的当前时间，实际上就是一个不断递增的整数。从1970年1月1日的格林威治时间为0，逐秒递增。

  返回当前计算机的时间戳：

  ```java
  System.out.println(System.currentTimeMillis());
  ```

  该时间戳在`java.time`中以`Instant`表示，也可以用`Instant.now()`获取当前的时间戳：

  ```java
  Instant now = Instant.now();
  System.out.println(now.getEpochSecond()); // 精确到秒
  ```

  使用时间戳常见当前时区的`ZonedDateTime`：

  ```java
  ZonedDateTime = now.atZone(ZoneId.systemDefault());
  ```

- 新旧API的转换：

  通过中间变量`Instant`对象即可实现转换。



# 单元测试

- 定义

  单元测试即针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此针对Java程序进行的单元测试就是针对单个Java方法的测试。

- JUnit

  JUnit是一个广泛使用的，专为Java设计的单元测试框架。下面是一个简单判等的测试。

  ```java
  import static org.junit.jupiter.api.Assertions.*;
  import org.junit.jupiter.api.Test;
  
  public class FactorialTest{
      @Test
      void testFact() {
          assertEquals(1, Factorial.fact(1));
      }
  }
  ```

  > [!TIP]
  >
  > 每个`@Test`方法内部的成员变量都是独立的。

- 测试编写规范

  1. 单元测试本身必须非常简单，看一下就能明白，绝不能再为测试代码编写测试
  2. 每个单元测试应当相互独立，互不干扰
  3. 测试时不但要覆盖常用的测试用例，还要特别注意测试边界条件。

- Fixture方法

  在测试时，我们经常遇到一个对象需要初始化，测试完还需要清理，如果每个`@Test`方法都写一遍重复代码，会显得比较麻烦。Fixture方法是为了给JUnit提供测试前准备，测试后清理的固定代码。

  - `@BeforeEach`和`@AfterEach`

    `@BeforeEach`用来初始化，`@AfterEach`用于清理资源。分别位于每个`@Test`方法的前后自动运行。

    ```java
    public class CalculatorTest {
        Calculator calculator
        
        @BeforeEach
        public void setUp() {
            this.calculator = new Calculator();
        }
        
        @AfterEach
        public void tearDown() {
            this.calculator = null;
        }
        
        @Test
        void test() {
            assertEquals(100, this.calculator.add(100));
        }
        
        @Test
        void test() {
            assertEquals(200, this.calculator.add(200));
        }
    }
    ```

  - `@BeforeAll`和`@AfterAll`

    当一些资源的初始化和清理更加繁琐，JUnit提供了`@BeforeAll`和`@AfterAll`，它们运行在**所有的**`@Test`的前后，且仅运行一次，因此它们只能初始化静态变量。

- 异常测试

  测试不仅要处理方法正确输出的情况，当方法出现错误时（抛出异常），测试也要涵盖到。因此对可能抛出的异常进行测试被称为异常测试。

  下面这个例子展示了一个测试捕获的异常的例子：

  ```java
  @Test
  void testNegative() {
      assertThrows(IllegalArgumentException.class, new Executable() {
          @Override
          public void execute() throws Throwable {
              Factorial.fact(-1);
          }
      });
  }
  ```

  JUnit提供了`assertThrows()`来期望捕获一个指定的异常，第二个参数使用匿名内部类封装要执行测试的代码。`assertThrows()`在捕获到异常时通过测试，为捕获到异常或者异常类型不对时，均表示测试失败。

- 条件测试

  当运行测试时，我们希望部分测试代码只针对某些具体的条件执行，例如一个方法的源代码针对Windows和Mac分别做了个性化解决方案，测试代码希望在Windows平台只运行针对Windows平台的测试代码，Mac平台同理。这样的给测试代码添加条件的方法称为条件测试。下面展示了一个针对Windows平台和Mac平台的测试代码。

  ```java
  @Test
  @EnabledOnOs(OS.WINDOWS)
  void testWindows() {
      assertEquals("C:\\test.ini", config.getConfigFile("test.ini"));
  }
  
  @Test
  @EnabledOnOs({ OS.LINUX, OS.MAC })
  void testLinuxAndMac() {
      assertEquals("/usr/local/test.cfg", config.getConfigFile("test.cfg"));
  }
  ```

  `@EnableOnOs`就是一个条件判断。

  还有一些其他的条件判断：

  - 只能在Java 9或更高版本执行的测试：`@DisabledOnJre(JRE.JAVA_8)`
  - 只能在64位操作系统上执行的测试：`@EnabledIfSystemProperty`

- 参数化测试

  将测试数据从代码中解放出来，代码中的输入和输出定义为参数，这种测试方法被称为参数化测试。JUnit提供了`@ParameterizedTest`注解结合各种参数源注解（如`@ValueSource`），用于参数化测试。

  ```java
  @ParameterizedTest
  @ValueSource(ints = { 0, 1, 5, 100 })
  void testAbs(int x) {
      assertEquals(x, Math.abs(x));
  }
  ```

  
# 正则表达式

- 定义

  如果想要判断一个字符串是否符合某个固定格式，通过撰写代码来逻辑判断显得过于复杂。正则表达式就是一个描述规则的字符串，所以只要编写正确的规则，就可以判断字符串是否合理。

- 使用

  例如"\d"代表匹配任意一个数字，但是在Java中 `\` 是一个转义字符，需要使用双反斜杠`\\`来表示单个反斜杠。

- 匹配规则

| 目标字符串               | 匹配规则                                        |
| ------------------------ | ----------------------------------------------- |
| 非ASCII字符              | `\u####`（十六机制），例如`\u548`匹配字符串`和` |
| 任意字符                 | `.`                                             |
| 单个数字                 | `\d`                                            |
| 一个字母或下划线         | `\w`                                            |
| 一个空格字符/一个Tab字符 | `\s`                                            |
| 单个非数字               | `\D`                                            |
| 单个非字母或下划线       | `\W`                                            |
| 单个非空格字符           | `\S`                                            |

- 重复匹配规则

​	如果需要多次匹配，例如匹配多个数字，就要用到重复匹配规则，直接加在后面。

| 目标重复次数     | 重复匹配规则   |
| ---------------- | -------------- |
| 任意个（0~无穷） | `*`，例如`\d*` |
| 至少一个         | `+`            |
| 0个或一个        | `?`            |
| 精确匹配n个字符  | `{3}`          |
| 匹配n~m个字符    | `{n,m}`        |
| 至少n个字符      | `{n,}`         |

- 复杂匹配规则

| 目标规则                               | 复杂匹配规则              |
| -------------------------------------- | ------------------------- |
| 以...开头的字符串                      | `^`，例如`^\d{3}`         |
| 以...结尾的字符串                      | `$`，例如`\d{3}$`         |
| 匹配一定范围的单个字符                 | `[...]`，例如[1-9]，[a-z] |
| 匹配不包括一定范围的单个字符的其他字符 | `[^...]`，例如\[^1-9]     |
| 或规则                                 | `|`                       |
| 分组                                   | `()`                      |

> 注意不要理解错[10-23]，他不是匹配10~23的数，而是匹配
>
> - 1
> - 0~2
> - 3
>
> 上述三个类别中任意一个数字，综合起来也就是匹配0~3的单个数字

- 分组匹配

  分组匹配可以方便我们提取不同组的子串。例如电话号码匹配串`(\d{3,4})-(\d{6,8})`可以方便我们快速提取区号和电话号。例子如下：

  ```java
  import java.util.regex.*;
  
  public class Main {
      public static void main(String[] args) {
          Pattern p = Pattern.compile("(\d{3,4})\-(\d{6,8})");
          Matcher m = p.matcher("010-12345678");
          if (m.matches()) {
              String g1 = m.group(1);
              String g2 = m.group(2);
              System.out.println(g1);
              System.out.println(g2);
          }
          else {
              System.out.println("匹配失败");
          }
      }
  }
  ```

  上述代码首先用`Pattern`对象匹配正则表达式，匹配后获得一个`Matcher`对象，如果匹配成功，就可以直接从`Matcher.group(index)`返回子串，index为0表示整个字符串，index为1表示第一个子串，inde为2表示第二个子串。

- 非贪婪匹配

  正则表达式默认采用的贪婪匹配的方式，即从左到右尽可能匹配多的字符，如果我们想要其匹配尽可能少的字符，就需要非贪婪匹配的方式。

  例如给定一串数字，判断该数字末尾的个数，"123000"有3个0。可以很容易写出表达式(\d+)(0*)，然后通`Pattern`和`Matcher`去识别提取。

  然而由于贪婪匹配，第一组的\d+就会匹配掉所有的数字，导致第二个子串始终为空串。

  所以我们要让\d+尽量少匹配，0*尽量多匹配，也即让\d+采用非贪婪匹配，在\d+后面添加个`?`即可表示非贪婪匹配。总的表达式为(\d+?)(0\*)

  再例如：这个正则表达式`(\d??)(9*)`，注意`\d?`表示匹配0个或1个数字，后面第二个`?`表示非贪婪匹配，因此，给定字符串`"9999"`，匹配到的两个子串分别是`""`和`"9999"`，因为对于`\d?`来说，可以匹配1个`9`，也可以匹配0个`9`，但是因为后面的`?`表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个`9`。

- 分割字符串

  ```java
  "a b c".split("\\s"); // { "a", "b", "c" }
  "a b  c".split("\\s"); // { "a", "b", "", "c" }
  "a,b ;; c".split("[\\,\\;\\s]+"); // { "a", "b", "c" }
  ```

- 替换字符串

  使用正则表达式替换字符串可以直接调用`String.replaceAll`，第一个参数是正则表达式，第二个参数是待替换的字符串。

  ```java
  String s = "The     quick\t\t brown   fox  jumps   over the  lazy dog.";
  String r = s.replaceAll("\\s+", " ");
  System.out.println(r); // "The quick brown fox jumps over the lazy dog."
  ```

- 反向引用

  `String.replaceAll()`传入的第二个参数可以使用`$1`，`$2`等来反向引用到匹配的子串。$1代表分组匹配的第一组，$2代表第二组。

  ```java
  String s = "the quick brown fox jumps over the lazy dog.";
  String r = s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
  System.out.println(r); // the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.
  ```
  

# 加密与安全

## ”三防“宗旨

- 防窃听
- 防篡改
- 防伪造

## 编码算法

编码算法的目的是将数据转换成另一种格式，方便传输，存储或处理。作用是为了保障数据的正确性和兼容性。

### 常用算法

- URL编码

  URL编码是吧网址的URL编码成服务器可识别的URL编码。例如：

  https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87

  具体来说，规则如下：

  - 如果字符是`A~Z`，`a~z`，`0~9`以及`-`，`_`，`.`和`*`等，则保持不变

  - 如果是其他字符，则先转换为UTF-8编码，然后对每个字节以`%XX`表示

    >  例如`中`的UTF-8编码是`0xe4b8ad`，它的URL编码是`%E4%B8%AD`

- Base64编码

  Base64编码是将二进制数据转为文本格式。

## 哈希算法

哈希算法又称摘要算法，作用是对一组输入数据进行计算，得到一个固定长度的输出摘要。以MD5算法为例，看看如何对输入就计算哈希：

```java
import java.security.MessageDigest;
import java.util.HexFormat;

public class Main {
    public static void main(String[] args) throws Exception {
        // 首先创建一个MessageDigest实例
        MessageDigest md = MessageDigest.getInstance("MD5"); // SHA类算法同理
        // 反复调用update输入数据
        md.update("Hello".getBytes("UTF-8"));
        md.update("World".getBytes("UTF-8"));
        byte[] result = md.digest();
        System.out.println(HexFormat.of().formatHex(result));
    }
}
```



### 特点

1. 相同的输入一定得到相同的输出
2. 不同的输入大概率得到不同的输出
3. 不可逆向解析

当两个不同的输入得到了相同的输出称为哈希碰撞。哈希碰撞是不可避免的，因为哈希算法是把一个无限的输入集合映射到一个有限的输出集合。一个安全的哈希算法需要满足：

- 碰撞概率低
- 输出不可推测

### 用途

1. 验证数据是否被篡改。

   例如下载软件时，经常在下载页显示的哈希。

   ![file-md5](https://liaoxuefeng.com/books/java/security/hash/file-md5.jpg)

   我们只要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，则说明文件下载正确。

2. 存储用户密码

   如果用户的原始密码直接存放到数据库，会产生极大安全风险。不仅管理员能够看到所有密码，数据库一但泄露，黑客就能获取所有明文口令。而存储用户密码的哈希值，就可以避免上述问题，即使拿到哈希值也不能逆向解析出原口令。

   > 彩虹表攻击
   >
   > 彩虹表是一个预先计算好常用密码和对应MD5的对照表。
   >
   > | 常用口令 | MD5                              |
   > | -------- | -------------------------------- |
   > | hello123 | f30aa7a662c728b7407c54ae6bfd27d1 |
   > | 12345678 | 25d55ad283aa400af464c76d713c07ad |
   > | passw0rd | bed128365216c019988915ed3add75fb |
   >
   > 如果用户使用了常用密码，黑客使用MD5一下就能反查到原始口令，这被称为彩虹表攻击。
   >
   > 为了抵御彩虹表攻击，我们可以为每个口令添加额外的随机数，这种方法被称为加盐（salt）：
   >
   > | username | salt  | password                         |
   > | -------- | ----- | -------------------------------- |
   > | bob      | H1r0a | a5022319ff4c56955e22a74abcc2c210 |
   > | alice    | 7$p2w | e5de688c99e961ed6e560b972dab8b6a |
   > | tim      | z5Sk9 | 1eee304b92dc0d105904e7ab58fd2f64 |

### 常用的哈希算法

- SHA算法

  包括SHA-1，SHA-256，SHA-512算法。

- MD5算法

  > [!WARNING]
  >
  > 已不推荐使用，因为MD5算法输出长度较短，短时间内可能被破解。

## Hmac算法

上文提到为例抵御彩虹表攻击，可以采用”加盐“的方式，Hmac算法是一种基于密钥的消息认证算法本质是为哈希算法加上密钥，通常与某种哈希算法配合使用，比加盐的方式更加安全。

## 对称加密算法

对称加密算法就是传统的用一个密码进行加密和解密。

- 常用的对称加密算法

  | 算法 | 密钥长度    | 工作模式             | 填充模式                                |
  | ---- | ----------- | -------------------- | --------------------------------------- |
  | DES  | 56/64       | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/...              |
  | AES  | 128/192/256 | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/PKCS7Padding/... |
  | IDEA | 128         | ECB                  | PKCS5Padding/PKCS7Padding/...           |

- AES算法+ECB模式加密样例：

  ```java
  import java.security.GeneralSecurityException;
  import java.util.Base64;
  
  import javax.crypto.Cipher;
  import javax.crypto.SecretKey;
  import javax.crypto.spec.SecretKeySpec;
  
  public class aaAES {
      public static void main(String[] args) throws Exception{
          String message = "Hello, world!";
          System.out.println("Message: " + message);
          byte[] key = "1234567890abcdef".getBytes("UTF-8");
          byte[] data = message.getBytes("UTF-8");
          byte[] encrypted = encrypt(key, data);
          System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(encrypted));
          byte[] decrypted = decrypt(key, encrypted);
          System.out.println("Decrypted: " + new String(decrypted, "UTF-8"));
      }
  
      public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException{
          Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
          SecretKey keySpec = new SecretKeySpec(key, "AES");
          // System.out.println(keySpec.toString());
          cipher.init(Cipher.ENCRYPT_MODE, keySpec);
          return cipher.doFinal(input);
      }
  
      public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException{
          Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
          SecretKey keySpec = new SecretKeySpec(key, "AES");
          cipher.init(Cipher.DECRYPT_MODE, keySpec);
          return cipher.doFinal(input);
          // return byte[];
      }
  }
  ```

## 密钥交换算法

对称机密算法解决了数据加密的问题，如果需要对数据进行解密，就必须从别人那里获得密钥。如何在不安全的信道上安全地传输密钥呢？

密钥交换算法即**DH（Diffie-Hellman）算法**，实现了双方在不直接传递密钥的情况下完成密钥交换。这个神奇的交换原理完全由数学理论支持。详见：[密钥交换算法 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/java/security/dh/index.html)

## 非对称加密算法

非对称加密就是加密和解密使用的不是相同的密钥。典型的代表就是RSA算法。

非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以公开各自的公钥，在N个人之间通信时，非对称加密只需要N个密钥对，每个人只需要管理自己的密钥对。而使用对称加密则需要`N*(N-1)/2`个密钥，因此每个人需要管理`N-1`个密钥，密钥管理难度大，且非常容易泄露。

非对称加密的缺点时运算速度非常慢。

实际应用中，非对称加密和对称加密总是一起使用，假设小明需要给小红传输加密文件，他俩首先交换各自的公钥，然后：

1. 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令并发给小红。
2. 小红用自己的RSA私钥解密得到AES口令。
3. 双方使用这个共享的AES口令用AES加密通信。

可见非对称加密应用在第一步，即加密”AES口令“，然后双方通信采用速度较快的AES对称加密，而不是缓慢的RSA非对称加密。

## 签名算法

使用非对称加密算法时，通常是一个公钥-私钥对，通常是公钥加密，私钥解密。

如果采用私钥加密，公钥解密，就可以达到信息不可被伪造，也不可被抵赖。

私钥加密得到的密文就是数字签名。所谓数字证书就是集合了多种密码学算法，用于实现数据加解密，身份认证，签名等多种功能的一种安全标准。











